<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Julien Pascal</title>
    <link>https://julienpascal.github.io/post/</link>
    <description>Recent content in Posts on Julien Pascal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Julien Pascal</copyright>
    <lastBuildDate>Sun, 28 Nov 2021 18:00:00 +0100</lastBuildDate>
    
	<atom:link href="https://julienpascal.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Artificial Neural Networks as universal function approximators</title>
      <link>https://julienpascal.github.io/post/ann_1/</link>
      <pubDate>Sun, 28 Nov 2021 18:00:00 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/ann_1/</guid>
      <description>Introduction Artificial Neural networks (ANN) are very trendy at the moment, and rightly so.
They are being used everywhere in big tech companies. For instance, when you use Google translate, or when recommandations appear on your Netflix feed, complex artificial neural networks are being used behind the scene. Behind the success of Alpha Go at the game of Go against Lee Sedol, an ANN was used to identify the next best move.</description>
    </item>
    
    <item>
      <title>Young&#39;s method (2010) to simulate a cross-section</title>
      <link>https://julienpascal.github.io/post/young_2010/</link>
      <pubDate>Mon, 18 Jan 2021 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/young_2010/</guid>
      <description>Introduction Solving economic models involves (i) finding the optimal response of individuals given the state of the economy (the policy functions); (ii) given the policy functions, simulating the model. While usually one must show great ingenuity and creativity for the former, the latter is often seen as trivial and not even mentioned. However, in this notebook I describe a simulation procedure that deserves to be advertised. Namely, I describe Young&amp;rsquo;s method (2010) to simulate a large number (infinity) of individuals.</description>
    </item>
    
    <item>
      <title>Aiyagari Model with Aggregate Uncertainty</title>
      <link>https://julienpascal.github.io/post/aiyagariaggregateuncertainty/</link>
      <pubDate>Tue, 19 May 2020 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/aiyagariaggregateuncertainty/</guid>
      <description>Introduction The Bewley-Huggett-Aiyagari-Imohoroğlu economies are the workhorse of modern macroeconomics. In these economies, markets are &amp;ldquo;incomplete&amp;rdquo;. Agents cannot fully insure against risk and decide to self-insure by holding a safe asset to smooth their consumption (see Ljungqvist and Sargent (2018) for a textbook treatment of this topic).
In this post, I consider the model of Aiyagari (1994). While the original model abstracts from aggregate fluctuations, Economists have since developed several techniques to simulate out-of-steady-state dynamics for this class of models.</description>
    </item>
    
    <item>
      <title>The GenBKM Algorithm</title>
      <link>https://julienpascal.github.io/post/genbkm/</link>
      <pubDate>Tue, 21 Apr 2020 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/genbkm/</guid>
      <description>In a previous post I presented the BKM algorithm , which can used to approximate solutions of macroeconomic models with aggregate uncertainty and heterogeneous agents. This class of models has been been of great interest for Economists for quite a long time. For instance, Aiyagari (1994) already hinted that taking into consideration heterogeneity along the business cycle is both theoretically important and challenging:
 This class of models may also be useful in resolving various asset return puzzles.</description>
    </item>
    
    <item>
      <title>The linear–quadratic regulator Part II</title>
      <link>https://julienpascal.github.io/post/lqr_partii/</link>
      <pubDate>Sun, 05 Apr 2020 16:00:00 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/lqr_partii/</guid>
      <description>This notebook builds upon what has been described in Part I. In Part I, we introduced the linear–quadratic regulator (LQR) framework in Python. We solved the linearized control problem.
In this notebook, we will see that we can do better. The basic idea is to follow the the evolution of &amp;ldquo;observables&amp;rdquo; — functions of the state space — instead of the evolution of the state itself using the Koopman operator.</description>
    </item>
    
    <item>
      <title>The linear–quadratic regulator Part I</title>
      <link>https://julienpascal.github.io/post/lqr/</link>
      <pubDate>Wed, 01 Apr 2020 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/lqr/</guid>
      <description>The two main goals of this blog post is to introduce what the linear–quadratic regulator (LQR) framework is and to show how to solve LQR problems using Python. The LQR is concerned with operating a dynamic system (a rocket, a car, the economy, etc.) at minimum cost.
In this blog post you will learn  what the LQR framework is how to simulate forward an ordinary differential equation using scipy how to solve for the optimal control using the Python Control Systems Library  The Jupyter notebook with the code used to generate this blog post can be found here</description>
    </item>
    
    <item>
      <title>A Primer on Computer Vision</title>
      <link>https://julienpascal.github.io/post/cnn/</link>
      <pubDate>Thu, 05 Dec 2019 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/cnn/</guid>
      <description>For a specific project on the housing market (here), I had to analyze thousands of photos. To do that, I used a convolutional neural network (CNN), which is a fancy name for a complicated function that can be &amp;ldquo;trained&amp;rdquo; to recognize patterns in images. In this blog post, I would like to introduce the &amp;ldquo;Hello World&amp;rdquo; of computer vision and CNN: the classification of hand-written digits from the MNIST dataset.</description>
    </item>
    
    <item>
      <title>Logistic Regression from Scratch</title>
      <link>https://julienpascal.github.io/post/logistic/</link>
      <pubDate>Fri, 22 Nov 2019 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/logistic/</guid>
      <description>The logistic model (also called logit model) is a natural candidate when one is interested in a binary outcome. For instance, a researcher might be interested in knowing what makes a politician successful or not. For the purpose of this blog post, &amp;ldquo;success&amp;rdquo; means the probability of winning an election. In that case, it would be sub-optimal to use a linear regression model to see what factors are associated with successful politicians, as the outcome variable is binary (a politician either wins or loses an election).</description>
    </item>
    
    <item>
      <title>Docker for Dummies</title>
      <link>https://julienpascal.github.io/post/docker/</link>
      <pubDate>Fri, 18 Oct 2019 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/docker/</guid>
      <description>In my quest for the perfect tool for reproducible science, I thought that the silver bullet was to wrap your code in a neat library/package and make it available to the world. Yet, I was wrong. Docker is a much cooler and a much more effective way for sharing your work with a broad audience. This post is a 101 introduction to Docker. I describe what is Docker and show one simple application with a script in Julia.</description>
    </item>
    
    <item>
      <title>OLS the Machine Learning Way</title>
      <link>https://julienpascal.github.io/post/ols_ml/</link>
      <pubDate>Sun, 29 Sep 2019 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/ols_ml/</guid>
      <description>Coming from an Economics/Econometrics background, I have always been a bit puzzled by the way several Machine Learning (ML) textbooks I have read solve the ordinary least squares model (OLS). When considering a linear model of the form:
$$ y = X \beta + e $$
with $e$ a zero-mean noise term, the closed-form solution associated with minimizing the mean square error is:
$$ \beta = (X&amp;rsquo;X)^{-1}X&amp;rsquo;y $$
Several ML textbooks explain that a recursive algorithm (see below) may be used to solve for $\beta$.</description>
    </item>
    
    <item>
      <title>The BKM Algorithm</title>
      <link>https://julienpascal.github.io/post/bkm/</link>
      <pubDate>Mon, 16 Sep 2019 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/bkm/</guid>
      <description>Finding solutions to economic models with heterogeneity and aggregate uncertainty is a notoriously difficult task. It is an active area of research in Mathematics (see mean field games with aggregate uncertainty). Because such models naturally arise when considering economic situations, Economists have developed a battery of techniques to (numerically) solve them. In this post, I would like to describe a recent algorithm by Boppart, Krusell and Mitman (BKM) that is both fast and accurate.</description>
    </item>
    
    <item>
      <title>Linear Time Iteration (Part II)</title>
      <link>https://julienpascal.github.io/post/lineartimeiteration2/</link>
      <pubDate>Mon, 26 Aug 2019 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/lineartimeiteration2/</guid>
      <description>In a previous post, I introduced the logic for the Linear Time Iteration (LTI) method (Pontus Rendahl (2017)). Now it&amp;rsquo;s time to apply the technique to a &amp;ldquo;real&amp;rdquo; (yet simple) economic model: a stochastic growth model with endogenous labor supply. The implementation is in Julia and is based a Matlab code by Pontus Rendahl available here. We will use a three-step approach:
 [1] solve the non-stochastic steady-state of the model [2] differentiate the system around the non-stochastic steady-state to obtain a linear difference equation of the form $A x_{t-1} + B x_{t} + C E_{t} [x_{t+1}] + u_{t} = 0$ [3] apply the LTI method to find the law of motion $x_{t} = F x_{t-1} + Q u_{t}$  Model We consider an economy populated by a representative household, deciding how much to work, save and consume at any given time.</description>
    </item>
    
    <item>
      <title>Linear Time Iteration (Part I)</title>
      <link>https://julienpascal.github.io/post/lineartimeiteration/</link>
      <pubDate>Sun, 25 Aug 2019 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/lineartimeiteration/</guid>
      <description>The details of solving rational expectation models are somewhat tricky. Yet, a recent paper by Pontus Rendahl underlines that an easy (and fast) method exists. What&amp;rsquo;s more, this method seems to be adapted to regime switching models and to models with a large state variable. The last point is particularly relevant if one studies heterogeneous agent models and uses Reiter&amp;rsquo;s (2009) method to solve them. In this post, I describe the method (closely following the paper) and give simple examples in Julia.</description>
    </item>
    
    <item>
      <title>Build your own cluster in 15 minutes</title>
      <link>https://julienpascal.github.io/post/buildyourcluster/</link>
      <pubDate>Wed, 24 Jul 2019 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/buildyourcluster/</guid>
      <description>During my PhD, I was lucky enough to secure access to a cluster maintained by a University. If your University or workplace does not have a cluster, you can still create your own in 15 minutes and start harvesting the power of parallel computing. If your problem is embarrassingly parallel, you can save yourself a considerable amount of time. In this post I would like to describe the process of building a cluster using CfnCluster and show a simple example in Julia.</description>
    </item>
    
    <item>
      <title>A Primer to Parallel Computing with Julia</title>
      <link>https://julienpascal.github.io/post/primerparallel/</link>
      <pubDate>Mon, 18 Mar 2019 18:53:22 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/primerparallel/</guid>
      <description>A Primer to Parallel Computing with Julia With this post, my aim is to provide a non-technical introduction to parallel computing using Julia. Our goal is to calculate an approximation of $\pi$ using Monte-Carlo. I will use this example to introduce some basic Julia functions and concepts. For a more rigorous explanation, the manual is a must-read.
Calculating $\pi$ using Monte-Carlo Our strategy to calculate an approximation of $\pi$ is quite simple.</description>
    </item>
    
    <item>
      <title>How to Create a Julia Package</title>
      <link>https://julienpascal.github.io/post/julia_package/</link>
      <pubDate>Wed, 06 Jun 2018 15:34:38 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/julia_package/</guid>
      <description>NOTE
This post is outdated. With the advent of Julia 1.0, the workflow for creating packages was significantly altered. An excellent guide can be found here.
In this post, my goal is to briefly explain how to create an unregistered Julia package for Julia 0.6.4, how to synchronize it with your Github account, and how to start testing your code automatically using TRAVIS CI. I started writing this post as a reminder to myself.</description>
    </item>
    
    <item>
      <title>The Simulated Method of Moments: a Parallel Implementation</title>
      <link>https://julienpascal.github.io/post/smm_parallel/</link>
      <pubDate>Wed, 06 Jun 2018 15:26:09 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/smm_parallel/</guid>
      <description>In my previous post, I discussed how the the simulated method of moments can be used to estimate parameters without using the likelihood function. This method is useful because many &amp;ldquo;real-life&amp;rdquo; applications result in untractable likelihood functions. In this post, I use the same toy example (estimation of the mean of a mutlivariate normal random variable) and show how to use the parallel computing capabilities of Julia and MomentOpt to speed-up the estimation.</description>
    </item>
    
    <item>
      <title>The Simulated Method of Moments</title>
      <link>https://julienpascal.github.io/post/smm/</link>
      <pubDate>Mon, 12 Feb 2018 15:07:33 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/smm/</guid>
      <description>As Thomas Sargent said:
 &amp;ldquo;A rational expectations equilibrium model is a likelihood function&amp;rdquo;
 However in many cases, the likelihood function is too complicated to be written down in closed form. To estimate the structural parameters of a given model, one can still use Monte-Carlo methods. In this post, I would like to describe the simulated method of moments (SMM), which is a widely used simulation-based estimation technique.</description>
    </item>
    
    <item>
      <title>Solving Bellman Equations by the Collocation Method</title>
      <link>https://julienpascal.github.io/post/collocation/</link>
      <pubDate>Thu, 07 Dec 2017 13:50:29 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/collocation/</guid>
      <description>A large class of economic models involves solving for functional equations of the form:
A well known example is the stochastic optimal growth model. An agent owns a consumption good $y$ at time $t$, which can be consumed or invested. Next period&amp;rsquo;s output depends on how much is invested at time $t$ and on a shock $z$ realized at the end of the current period. One can think of a farmer deciding the quantity of seeds to be planted during the spring, taking into account weather forecast for the growing season.</description>
    </item>
    
    <item>
      <title>Solving a simple RBC model in Dynare</title>
      <link>https://julienpascal.github.io/post/rbc_dynare/</link>
      <pubDate>Sat, 29 Jul 2017 13:44:23 +0100</pubDate>
      
      <guid>https://julienpascal.github.io/post/rbc_dynare/</guid>
      <description>Dynare is a rich software to solve, estimate and analyse rational expectation models. While it was originally designed to solve and estimate DSGE models, Dynare has also recently been used to solve and simulate heterogeneous agents models (see Winberry and Ragot for two very different approaches). Below is a simple example on how to solve and simulate a simple RBC model using Dynare.
A simple model The economy is composed of a representative agent who maximizes his expected discounted sum of utility by choosing consumption $C_t$ and labor $L_t$ for $t=1,&amp;hellip;,\infty$ $$ \sum_{t=1}^{+\infty}\big(\frac{1}{1+\rho}\big)^{t-1} E_t\Big[log(C_t)-\frac{L_t^{1+\gamma}}{1+\gamma}\Big] $$</description>
    </item>
    
  </channel>
</rss>