<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.44" />
  <meta name="author" content="Julien Pascal">
  <meta name="description" content="PhD candidate in Economics">

  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/github.min.css">
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.0/css/academicons.min.css" integrity="sha512-GGGNUPDhnG8LEAEDsjqYIQns+Gu8RBs4j5XGlxl7UfRaZBhCCm5jenJkeJL8uPuOXGqgl8/H1gjlWQDRjd3cUQ==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono">
  <link rel="stylesheet" href="/css/hugo-academic.css">
  

  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-114454001-1', 'auto');
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  

  <link rel="alternate" href="https://julienpascal.github.io/index.xml" type="application/rss+xml" title="Julien Pascal">
  <link rel="feed" href="https://julienpascal.github.io/index.xml" type="application/rss+xml" title="Julien Pascal">

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="https://julienpascal.github.io/post/smm_parallel/">

  

  <title>The Simulated Method of Moments: a Parallel Implementation | Julien Pascal</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Julien Pascal</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#projects">
            
            <span>Projects</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#teaching">
            
            <span>Teaching</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#publications">
            
            <span>Publications</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#posts">
            
            <span>Posts</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#contact">
            
            <span>Contact</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <h1 itemprop="name">The Simulated Method of Moments: a Parallel Implementation</h1>
    

<div class="article-metadata">

  <span class="article-date">
    <time datetime="2018-06-06 00:00:00 &#43;0000 UTC" itemprop="datePublished">
      Wed, Jun 6, 2018
    </time>
  </span>

  

  
  
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fjulienpascal.github.io%2fpost%2fsmm_parallel%2f"
         target="_blank">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=The%20Simulated%20Method%20of%20Moments%3a%20a%20Parallel%20Implementation&amp;url=https%3a%2f%2fjulienpascal.github.io%2fpost%2fsmm_parallel%2f"
         target="_blank">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjulienpascal.github.io%2fpost%2fsmm_parallel%2f&amp;title=The%20Simulated%20Method%20of%20Moments%3a%20a%20Parallel%20Implementation"
         target="_blank">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=https%3a%2f%2fjulienpascal.github.io%2fpost%2fsmm_parallel%2f&amp;title=The%20Simulated%20Method%20of%20Moments%3a%20a%20Parallel%20Implementation"
         target="_blank">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=The%20Simulated%20Method%20of%20Moments%3a%20a%20Parallel%20Implementation&amp;body=https%3a%2f%2fjulienpascal.github.io%2fpost%2fsmm_parallel%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>

    <div class="article-style" itemprop="articleBody">
      

<p>In my <a href="https://julienpascal.github.io/post/smm/" target="_blank">previous post</a>, I discussed how
the the simulated method of moments could be used to estimate parameters without
using the likelihood function. This method is useful because many &ldquo;real-life&rdquo; applications result in untractable likelihood functions. In this post, I use the same toy example (estimation of the mean of a mutlivariate normal random variable) and show how to use the
parallel computing capabilities of julia and <a href="https://github.com/floswald/MomentOpt.jl/" target="_blank">MomentOpt</a>
to speed-up the estimation.</p>

<h2 id="adding-workers">Adding workers</h2>

<p>In this example, the goal is to estimate the mean of 4-dimension normal random variable with unit variance, without using any information on the likelihood. If you start julia with several processors, MomentOpt will notice it and execute the code in parallel. The first step is to add &ldquo;workers&rdquo; to julia. A rule of thumb is to use as many workers as you have processors on your system (4 in my case).</p>

<pre><code class="language-julia"># Current number of workers

#--------------------------

currentWorkers = nprocs()

println(&quot;Initial number of workers = $(currentWorkers)&quot;)

# I want to have 4 workers running

#--------------------------------

maxNumberWorkers = 4

while nprocs() &lt; maxNumberWorkers

    addprocs(1)

end

# check the number of workers:

#----------------------------

currentWorkers = nprocs()

println(&quot;Number of workers = $(currentWorkers)&quot;)

Initial number of workers = 1
Number of workers = 4
</code></pre>

<h2 id="everywhere">@everywhere</h2>

<p>When running julia with several workers, you have to add the macro @everywhere when loading packages and when defining functions. More details on parallel computing with julia can be found <a href="https://docs.julialang.org/en/v0.6.0/manual/parallel-computing/" target="_blank">here.</a></p>

<pre><code class="language-julia">#---------------------------------------------------------------------------------------------------------
# Julien Pascal
# https://julienpascal.github.io/
# last edit: 06/06/2018
#
# Julia script that shows how the simulated method of moments can be used in
# a simple setting: estimation of the mean of a Normal r.v.
# This version was built to be executed with several processors
# For instance, start julia with: julia -p 4
#
# I use the package MomentOpt: https://github.com/floswald/MomentOpt.jl
#
# Code heavily based on the file https://github.com/floswald/MomentOpt.jl/blob/master/src/mopt/Examples.jl
#----------------------------------------------------------------------------------------------------------

@everywhere using MomentOpt
@everywhere using GLM
@everywhere using DataStructures
@everywhere using DataFrames
@everywhere using Plots
#plotlyjs()
@everywhere pyplot()

#------------------------------------------------
# Options
#-------------------------------------------------
# Boolean: do you want to save the plots to disk?
savePlots = true

#------------------------
# initialize the problem:
#------------------------
# Specify the initial values for the parameters, and their support:
#------------------------------------------------------------------
pb = OrderedDict(&quot;p1&quot; =&gt; [0.2,-3,3] , &quot;p2&quot; =&gt; [-0.2,-2,2], &quot;p3&quot; =&gt; [0.1,0,10], &quot;p4&quot; =&gt; [-0.1,-10,0])
# Specify moments to be matched + subjective weights:
#----------------------------------------------------
trueValues = OrderedDict(&quot;mu1&quot; =&gt; [-1.0] , &quot;mu2&quot; =&gt; [1.0], &quot;mu3&quot; =&gt; [5.0], &quot;mu4&quot; =&gt; [-4.0])
moms = DataFrame(name=[&quot;mu1&quot;,&quot;mu2&quot;,&quot;mu3&quot;, &quot;mu4&quot;],value=[-1.0,1.0, 5.0, -4.0], weight=ones(4))




# objfunc_normal(ev::Eval)
#
# GMM objective function to be minized.
# It returns a weigthed distance between empirical and simulated moments
#
@everywhere function objfunc_normal(ev::Eval; verbose = false)

    start(ev)


    # when running in parallel, display worker's id:
    #-----------------------------------------------
    if verbose == true
        if nprocs() &gt; 1
          println(myid())
        end
    end

    # extract parameters from ev:
    #----------------------------
    mu  = collect(values(ev.params))

    # compute simulated moments
    #--------------------------
    # Monte-Carlo:
    #-------------
    ns = 10000 #number of i.i.d draws from N([mu], sigma)
    #initialize a multivariate normal N([mu], sigma)
    #mu is a four dimensional object
    #sigma is set to be the identity matrix
    sigma = [1.0 ;1.0; 1.0; 1.0]
    # draw ns observations from N([mu], sigma):
    randMultiNormal = MomentOpt.MvNormal(mu,MomentOpt.PDiagMat(sigma))
    # calculate the mean of the simulated data
    simM            = mean(rand(randMultiNormal,ns),2)
    # store simulated moments in a dictionary
    simMoments = Dict(:mu1 =&gt; simM[1], :mu2 =&gt; simM[2], :mu3 =&gt; simM[3], :mu4 =&gt; simM[4])

    # Calculate the weighted distance between empirical moments
    # and simulated ones:
    #-----------------------------------------------------------
    v = Dict{Symbol,Float64}()
    for (k, mom) in dataMomentd(ev)
        # If weight for moment k exists:
        #-------------------------------
        if haskey(MomentOpt.dataMomentWd(ev), k)
            # divide by weight associated to moment k:
            #----------------------------------------
            v[k] = ((simMoments[k] .- mom) ./ MomentOpt.dataMomentW(ev,k)) .^2
        else
            v[k] = ((simMoments[k] .- mom) ) .^2
        end
    end

    # Set value of the objective function:
    #------------------------------------
    setValue(ev, mean(collect(values(v))))

    # also return the moments
    #-----------------------
    setMoment(ev, simMoments)

    # flag for success:
    #-------------------
    ev.status = 1

    # finish and return
    finish(ev)

    return ev
end



# Initialize an empty MProb() object:
#------------------------------------
mprob = MProb()

# Add structural parameters to MProb():
# specify starting values and support
#--------------------------------------
addSampledParam!(mprob,pb)

# Add moments to be matched to MProb():
#--------------------------------------
addMoment!(mprob,moms)

# Attach an objective function to MProb():
#----------------------------------------
addEvalFunc!(mprob, objfunc_normal)


# estimation options:
#--------------------
# number of iterations for each chain
niter = 1000
# number of chains
# nchains = nprocs()
nchains = 4

opts = Dict(&quot;N&quot;=&gt;nchains,
        &quot;maxiter&quot;=&gt;niter,
        &quot;maxtemp&quot;=&gt; 5,
        &quot;coverage&quot;=&gt;0.025,
        &quot;sigma_update_steps&quot;=&gt;10,
        &quot;sigma_adjust_by&quot;=&gt;0.01,
        &quot;smpl_iters&quot;=&gt;1000,
        &quot;parallel&quot;=&gt;true,
        &quot;maxdists&quot;=&gt;[0.05 for i in 1:nchains],
        &quot;mixprob&quot;=&gt;0.3,
        &quot;acc_tuner&quot;=&gt;12.0,
        &quot;animate&quot;=&gt;false)



#---------------------------------------
# Let's set-up and run the optimization
#---------------------------------------
# set-up BGP algorithm:
MA = MAlgoBGP(mprob,opts)

# run the estimation:
@time MomentOpt.runMOpt!(MA)

# show a summary of the optimization:
@show MomentOpt.summary(MA)
</code></pre>

<h3 id="inference">Inference</h3>

<p>When using the <a href="https://arxiv.org/abs/1108.3423" target="_blank">BGP algorithm</a>, inference can be done using the first chain. Other chains are used to explore the state space and help to exit potential local minima, but they are not meant to be used for inference. I discard the first 10th observations to get rid of the influence of the starting values. Visual inspection of the first chain suggests that the stationary part of the Markov chain was reached at this stage. I then report the quasi posterior mean and median for each parameter. As reported below, we are quite close to the true values.</p>

<pre><code class="language-julia"># Plot histograms for the first chain, the one with which inference should be done.
# Other chains are used to explore the space and avoid local minima
#-------------------------------------------------------------------------------
p1 = histogram(MA.chains[1])
display(p1)

if savePlots == true
    savefig(p1, joinpath(pwd(),&quot;histogram_chain1.svg&quot;))
end

# Plot the realization of the first chain
#----------------------------------------
p2 = plot(MA.chains[1])
if savePlots == true
    savefig(p2, joinpath(pwd(),&quot;history_chain_1.svg&quot;))
end
display(p2)


# Realization of the first chain:
#-------------------------------
dat_chain1 = MomentOpt.history(MA.chains[1])

# discard the first 10th of the observations (&quot;burn-in&quot; phase):
#--------------------------------------------------------------
dat_chain1[round(Int, niter/10):niter, :]

# keep only accepted draws:
#--------------------------
dat_chain1 = dat_chain1[dat_chain1[:accepted ].== true, : ]

# create a list with the parameters to be estimated
parameters = [Symbol(String(&quot;mu$(i)&quot;)) for i=1:4]
# list with the corresponding priors:
#------------------------------------
estimatedParameters = [Symbol(String(&quot;p$(i)&quot;)) for i=1:4]


# Quasi Posterior mean and quasi posterior median for each parameter:
#-------------------------------------------------------------------
for (estimatedParameter, param) in zip(estimatedParameters, parameters)

  println(&quot;Quasi posterior mean for $(String(estimatedParameter)) = $(mean(dat_chain1[estimatedParameter]))&quot;)
  println(&quot;Quasi posterior median for $(String(estimatedParameter)) = $(median(dat_chain1[estimatedParameter]))&quot;)
  println(&quot;True value = $(trueValues[String(param)][])&quot;)

end

# Output:
#--------
# Quasi posterior mean for p1 = -0.9160461484604642
# Quasi posterior median for p1 = -0.9589739759449558
# True value = -1.0
# Quasi posterior mean for p2 = 0.9888798123473025
# Quasi posterior median for p2 = 1.0675028518780796
# True value = 1.0
# Quasi posterior mean for p3 = 4.922658319685393
# Quasi posterior median for p3 = 4.989662707150382
# True value = 5.0
# Quasi posterior mean for p4 = -3.898597557236236
# Quasi posterior median for p4 = -3.968649064061086
# True value = -4.0
</code></pre>

<h4 id="figure-1">Figure 1</h4>

<table>
<thead>
<tr>
<th align="center"><img src="/img/history_chain_1_Parallel.svg" alt="History of chain 1" /></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><em>History of chain 1</em></td>
</tr>
</tbody>
</table>

<h4 id="figure-2">Figure 2</h4>

<table>
<thead>
<tr>
<th align="center"><img src="/img/histogram_chain_1_Parallel.svg" alt="Histograms for chain 1" /></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><em>Histograms for chain 1</em></td>
</tr>
</tbody>
</table>

<h2 id="safety-checks">Safety checks</h2>

<p>In this toy example, we know we have global identification. However, in more complicated applications, global identification may be hard to prove analytically. A common practice is to make sure that the objective function is &ldquo;well-behaved&rdquo; in a neighborhood of the solution using slices. The graph below shows that there is no flat region in the neighborhood of the solution, suggesting (at least) local identification of the parameters.</p>

<pre><code class="language-julia"># plot slices of objective function
# grid with 20 points
#-----------------------------------
s = doSlices(mprob,20)

# plot slices of the objective function:
#---------------------------------------
p = MomentOpt.plot(s,:value)
display(p)

if savePlots == true
    Plots.savefig(p, joinpath(pwd(),&quot;slices_Normal.svg&quot;))
end



# Produce more precise plots with respect to each parameter:
#-----------------------------------------------------------
for symbol in parameters

  p = MomentOpt.plot(s,symbol)
  display(p)

  if savePlots == true
      Plots.savefig(p, joinpath(pwd(),&quot;slices_Normal_$(String(symbol)).svg&quot;))
  end


end
</code></pre>

<h4 id="figure-3">Figure 3</h4>

<table>
<thead>
<tr>
<th align="center"><img src="/img/slices_Normal_Parallel.svg" alt="Slices of the objective function" /></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><em>Slices of the objective function</em></td>
</tr>
</tbody>
</table>

<h2 id="parallel-versus-serial">Parallel versus Serial</h2>

<p>Here is benchmark of running the code above in serial versus in parallel
(starting julia with 4 workers):</p>

<ul>
<li>Serial: 639.661831 seconds (12.52 M allocations: 1.972 GiB, 97.50% gc time)</li>
<li>Parallel: 372.454707 seconds (279.32 M allocations: 14.843 GiB, 2.19% gc time)</li>
</ul>

<p>Computing time is approximately divided by 2 when executing the parallel version.</p>

<h2 id="notebook">Notebook</h2>

<p>A jupyter notebook containing the code in this post (with some slight modifications)
can be downloaded <a href="https://github.com/JulienPascal/ExampleMomentOpt/blob/master/Example_MomentOpt_parallel.ipynb" target="_blank">here</a>.</p>

    </div>
  </div>

</article>

<div class="container">
  <nav>
  <ul class="pager">
    
    <li class="previous"><a href="https://julienpascal.github.io/post/smm/"><span
      aria-hidden="true">&larr;</span> The Simulated Method of Moments</a></li>
    

    
    <li class="next"><a href="https://julienpascal.github.io/post/createjuliapackage/">How to Create a Julia Package <span
      aria-hidden="true">&rarr;</span></a></li>
    
  </ul>
</nav>

</div>

<div class="article-container">
  

</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 Julien Pascal &middot; 

      Powered by the <a href="https://github.com/gcushen/hugo-academic" target="_blank">Academic
      theme</a> for <a href="http://gohugo.io" target="_blank">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js" integrity="sha512-jGsMH83oKe9asCpkOVkBnUrDDTp8wl+adkB2D+//JtlxO4SrLoJdhbOysIFQJloQFD+C4Fl1rMsQZF76JjV0eQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js" integrity="sha512-iHzEu7GbSc705hE2skyH6/AlTpOfBmkx7nUqTLGzPYR+C1tRaItbRlJ7hT/D3YQ9SV0fqLKzp4XY9wKulTBGTw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/TweenMax.min.js" integrity="sha512-Z5heTz36xTemt1TbtbfXtTq5lMfYnOkXM2/eWcTTiLU01+Sw4ku1i7vScDc8fWhrP2abz9GQzgKH5NGBLoYlAw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/plugins/ScrollToPlugin.min.js" integrity="sha512-CDeU7pRtkPX6XJtF/gcFWlEwyaX7mcAp5sO3VIu/ylsdR74wEw4wmBpD5yYTrmMAiAboi9thyBUr1vXRPA7t0Q==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    <script src="/js/hugo-academic.js"></script>
    

    
    
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>

      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/julia.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/python.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/shell.min.js"></script>
      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML" integrity="sha512-tOav5w1OjvsSJzePRtt2uQPFwBoHt1VZcUq8l8nm5284LEKE9FSJBQryzMBzHxY5P0zRdNqEcpLIRVYFNgu1jw==" crossorigin="anonymous"></script>
    
    

  </body>
</html>

