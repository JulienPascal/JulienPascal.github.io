<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="generator" content="Source Themes Academic 4.1.0">
  <meta name="generator" content="Hugo 0.54.0" />

  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Julien Pascal, PhD">

  
  
  
    
  
  <meta name="description" content="Introduction In a previous post, I discussed why Artificial Neural Networks (ANN) are very popular tools: (i) they can approximate a very large set of functions (ii) they work well in high-dimensional spaces (iii) we can train them efficiently using gradient descent (even better if you have a GPU). In the application part, I showed how to use them in practice using Julia and Flux.jl with two toy examples.">

  
  <link rel="alternate" hreflang="en-us" href="https://julienpascal.github.io/post/ann_2/">

  


  

  

  

  

  

  

  
  
  
  <meta name="theme-color" content="#2962ff">
  

  
  
  
  
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/css/bootstrap.min.css" integrity="sha256-eSi1q2PG6J7g7ib17yAaWMcrr5GrtohYChqibrV7PBE=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css" integrity="sha256-uFVgMKfistnJAfoCUQigIl+JfUaP47GrRKjf6CTPVmw=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.0/css/all.css" integrity="sha384-aOkxzJ5uQz7WBObEZcHvV5JvRW3TUc2rNPA7pe3AwnsUohiw1Vj2Rgx2KSOkF5+h" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" integrity="sha256-ygkqlh3CYSUri3LhQxzdcm0n1EQvH2Y+U5S2idbLtxs=" crossorigin="anonymous">

    
    
    
      
    
    
      
      
        
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" crossorigin="anonymous" title="hl-light">
          <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/dracula.min.css" crossorigin="anonymous" title="hl-dark" disabled>
        
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.css" integrity="sha512-M2wvCLH6DSRazYeZRIm1JnYyh22purTM+FDB5CsyxtQJYeKq83arPe5wgbNmcFXGqiSH2XR8dT/fJISVA1r/zQ==" crossorigin="anonymous">
    

    

  

  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Montserrat:400,700|Roboto:400,400italic,700|Roboto+Mono">
  

  <link rel="stylesheet" href="/styles.css">
  

  
  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'G-BSZS1F0NHL', 'auto');
      
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  
  

  
  <link rel="alternate" href="https://julienpascal.github.io/index.xml" type="application/rss+xml" title="Julien Pascal">
  <link rel="feed" href="https://julienpascal.github.io/index.xml" type="application/rss+xml" title="Julien Pascal">
  

  <link rel="manifest" href="/site.webmanifest">
  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/icon-192.png">

  <link rel="canonical" href="https://julienpascal.github.io/post/ann_2/">

  
  
  
  
    
    
  
  <meta property="twitter:card" content="summary">
  
  <meta property="twitter:site" content="@Juli3nPascal">
  <meta property="twitter:creator" content="@Juli3nPascal">
  
  <meta property="og:site_name" content="Julien Pascal">
  <meta property="og:url" content="https://julienpascal.github.io/post/ann_2/">
  <meta property="og:title" content="Artificial Neural Networks to Solve Economic Models | Julien Pascal">
  <meta property="og:description" content="Introduction In a previous post, I discussed why Artificial Neural Networks (ANN) are very popular tools: (i) they can approximate a very large set of functions (ii) they work well in high-dimensional spaces (iii) we can train them efficiently using gradient descent (even better if you have a GPU). In the application part, I showed how to use them in practice using Julia and Flux.jl with two toy examples."><meta property="og:image" content="https://julienpascal.github.io/img/icon-192.png">
  <meta property="og:locale" content="en-us">
  
  <meta property="article:published_time" content="2022-01-03T18:00:00&#43;01:00">
  
  <meta property="article:modified_time" content="2022-01-03T18:00:00&#43;01:00">
  

  

  

  <title>Artificial Neural Networks to Solve Economic Models | Julien Pascal</title>

</head>
<body id="top" data-spy="scroll" data-target="#TableOfContents" data-offset="71" >
  <aside class="search-results" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" role="textbox" spellcheck="false" type="search">
        
      </div>

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>


<nav class="navbar navbar-light fixed-top navbar-expand-lg py-0" id="navbar-main">
  <div class="container">

    
      <a class="navbar-brand" href="/">Julien Pascal</a>
      
      <button type="button" class="navbar-toggler" data-toggle="collapse"
              data-target="#navbar" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
        <span><i class="fas fa-bars"></i></span>
      </button>
      

    
    <div class="collapse navbar-collapse" id="navbar">

      
      
      <ul class="navbar-nav mr-auto">
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#about">
            
            <span>Home</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#projects">
            
            <span>Projects</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#teaching">
            
            <span>Teaching</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#publications">
            
            <span>Publications</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#posts">
            
            <span>Posts</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#computing">
            
            <span>Computing</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/#contact">
            
            <span>Contact</span>
            
          </a>
        </li>

        
        

        

        
        
        
          
        

        <li class="nav-item">
          <a class="nav-link" href="/pdf/Julien_Pascal_Academic_Resume.pdf">
            
            <span>Academic Resume</span>
            
          </a>
        </li>

        
        

      
      </ul>
      <ul class="navbar-nav ml-auto">
      

        

        
        <li class="nav-item">
          <a class="nav-link js-search" href="#"><i class="fas fa-search" aria-hidden="true"></i></a>
        </li>
        

        

        
        <li class="nav-item">
          <a class="nav-link js-dark-toggle" href="#"><i class="fas fa-moon" aria-hidden="true"></i></a>
        </li>
        

      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  












  

  
  
  
<div class="article-container pt-3">
  <h1 itemprop="name">Artificial Neural Networks to Solve Economic Models</h1>

  

  
    



<meta content="2022-01-03 18:00:00 &#43;0100 CET" itemprop="datePublished">
<meta content="2022-01-03 18:00:00 &#43;0100 CET" itemprop="dateModified">

<div class="article-metadata">

  
  

  
  <span class="article-date">
    
    
      
    
    <time>Jan 3, 2022</time>
  </span>
  

  

  
  <span class="middot-divider"></span>
  <span class="article-reading-time">
    19 min read
  </span>
  

  
  

  

  
    
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=Artificial%20Neural%20Networks%20to%20Solve%20Economic%20Models&amp;url=https%3a%2f%2fjulienpascal.github.io%2fpost%2fann_2%2f"
         target="_blank" rel="noopener">
        <i class="fab fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fjulienpascal.github.io%2fpost%2fann_2%2f"
         target="_blank" rel="noopener">
        <i class="fab fa-facebook-f"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjulienpascal.github.io%2fpost%2fann_2%2f&amp;title=Artificial%20Neural%20Networks%20to%20Solve%20Economic%20Models"
         target="_blank" rel="noopener">
        <i class="fab fa-linkedin-in"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=https%3a%2f%2fjulienpascal.github.io%2fpost%2fann_2%2f&amp;title=Artificial%20Neural%20Networks%20to%20Solve%20Economic%20Models"
         target="_blank" rel="noopener">
        <i class="fab fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=Artificial%20Neural%20Networks%20to%20Solve%20Economic%20Models&amp;body=https%3a%2f%2fjulienpascal.github.io%2fpost%2fann_2%2f">
        <i class="fas fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>

    







  









  
</div>



  <div class="article-container">

    <div class="article-style" itemprop="articleBody">
      

<h2 id="introduction">Introduction</h2>

<p>In <a href="https://julienpascal.github.io/post/ann_1/" target="_blank">a previous post</a>, I discussed why Artificial Neural Networks (ANN) are very popular tools: (i) they can approximate a very large set of functions (ii) they work well in high-dimensional spaces (iii) we can train them efficiently using gradient descent (even better if you have a GPU). In the application part, I showed how to use them in practice using <a href="https://julialang.org/" target="_blank">Julia</a> and <a href="https://github.com/FluxML/Flux.jl" target="_blank">Flux.jl</a> with two toy examples.</p>

<p>Now it&rsquo;s time to be a bit more ambitious. In my previous post, we could sample from the function we wanted to approximate. However, in many instances we cannot simply do that. <strong>The unknown element</strong> is the <strong>function we want to approximate</strong>.</p>

<p><strong>TL;DR: ANN work well to approximate unknown functions.</strong></p>

<p>The notebook for this post is available <a href="https://github.com/JulienPascal/ANN_Flux" target="_blank">here</a>.</p>

<h2 id="i-theory">I. Theory</h2>

<p>The cornerstone of Macro and Labour Economics is the dynamic optimization problem, in which an agent chooses a series of actions, taking account a set of constraints and the evolution of the state of the economy. A classical example is the a central planner deciding <a href="https://en.wikipedia.org/wiki/Ramsey%E2%80%93Cass%E2%80%93Koopmans_model" target="_blank">how much to save and consume</a> at any point in time. Another example would be <a href="https://www.jstor.org/stable/2297896" target="_blank">a worker searching for a job and deciding which job to accept and when to resign</a>.</p>

<p>These types of problems naturally lend themselves to the following <a href="https://en.wikipedia.org/wiki/Bellman_equation" target="_blank">Bellman equation</a>:</p>

<p>$$ V(x,z) = \max_{c \in \Gamma(x,z)}[ F(x,c,z) + \beta E[ V(T(x,c), z&rsquo;) ]$$</p>

<p>where $x$ is a known state variable and $z$ is a random variable following a Markov process. Both $x$ and $z$ are vectors. The function $\Gamma(.)$ represents the set of possible actions given a current state and the function $T(.)$ captures the transition from one state to another when an action is taken. The variable $\beta$ is a discount factor strictly smaller than one and the $E$ represent an expectation operator.</p>

<p>I do not want to delve too much into the fascinating theory of optimal control. The point is that the unknown is the function $V(.)$. Given the good properties of ANN mentioned above, one may be tempted to use them to approximate the true $V(.)$. And this is exactly what we are going to do.</p>

<h2 id="ii-application">II. Application</h2>

<p>For the application, let&rsquo;s focus on the model of the labour market of <a href="https://www.aeaweb.org/articles?id=10.1257/aer.20131118" target="_blank">Lise and Robin 2017</a>.Why? Because I have worked a lot with this model <a href="https://www.theses.fr/2020IEPP0013" target="_blank">during my PhD</a> and also because the model has really nice properties. The model features <strong>heterogeneous firms, workers</strong> (one can think of large versus small firms and workers with different skills) and <strong>business cycle fluctuations</strong> (booms and busts). Despite the underlying complexity, the model lends itself to a pretty simple Bellman equation:</p>

<p>$$ S(x,y,z) = s(x,y,z) + \frac{1 - \delta}{1 + r} E_{z&rsquo;|z} [ max(S(x,y,z&rsquo;), 0) ] $$</p>

<p>where $x$ is the worker&rsquo;s type; $y$ the firm&rsquo;s type; $z$ the aggregate (stochastic) state of the economy; $\delta$ the probability that a current job is going to be destroyed next period for exogenous reasons and $r$ the interest rate. The function $s(x,y,z)$ captures the value of net output when a worker of type $x$ works with a firm of type $y$ when the state of the economy is $z$. If the job is not productive enough, workers and firms decide to separate, which happens when $S(x,y,z) &lt; 0$. This is why there is a max operator within the expectation operator.</p>

<p>What we want to do is to use an ANN such that:</p>

<p>$$ ANN(x,y,z|\theta) = s(x,y,z) + \frac{1 - \delta}{1 + r} E_{z&rsquo;|z} [ ANN(x,y,z&rsquo;|\theta), 0) ] $$</p>

<p>Note that this equation can be rewritten as:</p>

<p>$$ ANN(x,y,z|\theta) - s(x,y,z) - \frac{1 - \delta}{1 + r} E_{z&rsquo;|z} [ ANN(x,y,z&rsquo;|\theta), 0) ] = 0$$</p>

<p>Our approximation is not going to be 100 percent perfect. But we can hope to find a good value of $\theta$ by minimizing the Mean Squared Error</p>

<p>$$ \frac{1}{n}\sum(y_i - \hat{y}_i)^2 $$</p>

<p>where $y_i$ is 0 everywhere and $\hat{y}_i = ANN(x_i,y_i,z_i|\theta) - \frac{1 - \delta}{1 + r} E_{z_i&rsquo;|z_i} [ ANN(x_i,y_i,z_i&rsquo;|\theta), 0) ] - s(x_i,y_i,z_i)$. Here the index $i$ captures the idea that we are going to draw several points from the space $X \times Y \times Z$</p>

<h3 id="ii-a-preliminaries">II. A. Preliminaries</h3>

<p>Let&rsquo;s load useful packages and define a structure (using <a href="https://github.com/mauro3/Parameters.jl" target="_blank">Parameters.jl</a>) to hold parameter values and primitive functions of the model.</p>

<pre><code class="language-julia">using Random
using DataFrames
using DataStructures
using Statistics
using Plots
using IterTools
using Flux
using Flux.Data: DataLoader
using ProgressMeter
using Parameters
using Expectations
using Distributions
using Surrogates
using LinearAlgebra
using LaTeXStrings
using Interpolations
using BenchmarkTools
using Parameters
using StatsPlots
using Kronecker
using SparseArrays
using CUDA
gr()

if CUDA.has_cuda()
    device = gpu
    @info &quot;GPU available&quot;
else
    device = cpu
    @info &quot;GPU not available&quot;
end
</code></pre>

<pre><code>┌ Info: GPU not available
└ @ Main In[120]:30
</code></pre>

<pre><code class="language-julia">@with_kw struct Params
    x_min::Float64 = 0.0
    x_max::Float64 = 1.0
    y_min::Float64 = 0.0
    y_max::Float64 = 1.0
    nx::Int64 = 21 # grid points for human capital
    ny::Int64 = 21 # grid points for firm productivity
    dt::Float64 = 1.0/52.0 # length of a period in years
    r::Float64 = (1.0 + 0.05)^dt - 1.0 # interest rate
    delta::Float64 = 0.0127012273 #job destrution rate
    epsilon::Float64 = 0.001 # distance to stay away from bounds of the interval
    x_grid = collect(range(x_min + epsilon, x_max - epsilon, length = nx))
    y_grid = collect(range(y_min + epsilon, y_max - epsilon, length = nx))
    # log of aggregate shocks are AR(1):
    # ln(zt) = rho*ln(zt-1) + e_k
    # with e_k distributed as N(0,psi^2)
    # and psi = sigma*sqrt(1-rho²)
    rho::Float64 = 0.9997369438 #persitence parameter
    sigma::Float64 = 0.0714488990 #volatility parameter
    psi::Float64 = sigma*sqrt(1.0 - rho^2) #std dev. of innovation term
    distrib_innovation::Any = Normal(0, psi) #0 mean and std = psi
    nb_nodes::Int64 = 10 #number nodes for the expectation
    E::Any = expectation(distrib_innovation, n = nb_nodes) #expectation operator
    nodes_E = nodes(E) #nodes for expectation
    weigths_E = weights(E) #weights for expectation
    f0::Float64     =    6.0873503685 # market production parameter
    f1::Float64     =    0.0025488557 # market production parameter
    f2::Float64     =    2.0529182143 # market production parameter
    f3::Float64     =    -0.1400252578 # market production parameter
    f4::Float64     =    8.0349795180 # market production parameter
    f5::Float64     =    -1.9072145913 # market production parameter
    f6::Float64     =    6.5961298483 # market production parameter
    b0::Float64     = 0.7 # home production parameter
    p_xyz::Function = (x, y, z) -&gt; f0*z*(f1 + f2*x + f3*y + f4*(x^2) + f5*(y^2) + f6*x*y)*dt #value of market production
    b_x::Function = (x) -&gt; b0*p_xyz(x, x, 1.0) #value of market production
    s_xyz::Function = (x,y,z) -&gt; p_xyz(x,y,z) - b_x(x) #surplus
    # VECTORIZED FUNCTIONS
    # input of the form:
    # row: observation
    # column: dimension
    p_xyz_v::Function = x -&gt; f0.*x[:,3].*(f1 .+ f2.*x[:,1] .+ f3.*x[:,2] .+ f4.*(x[:,1].^2) .+ f5.*(x[:,2].^2) .+ f6.*x[:,1].*x[:,2]).*dt #value of market production
    b_x_v::Function = x -&gt; b0.*f0.*1.0.*(f1 .+ f2.*x[:,1] .+ f3.*x[:,1] .+ f4.*(x[:,1].^2) .+ f5.*(x[:,1].^2) .+ f6.*x[:,1].*x[:,1]).*dt #value of market production
    s_xyz_v::Function = x -&gt; p_xyz_v(x) .- b_x_v(x) #surplus
    # VECTORIZED FUNCTIONS
    # input of the form:
    # row: dimension
    # column: observation
    p_xyz_r::Function = x -&gt; f0.*x[3, :].*(f1 .+ f2.*x[1, :] .+ f3.*x[2,:] .+ f4.*(x[1,:].^2) .+ f5.*(x[2,:].^2) .+ f6.*x[1,:].*x[2,:]).*dt #value of market production
    b_x_r::Function = x -&gt; b0.*f0.*1.0.*(f1 .+ f2.*x[1,:] .+ f3.*x[1,:] .+ f4.*(x[1,:].^2) .+ f5.*(x[1,:].^2) .+ f6.*x[1,:].*x[1,:]).*dt #value of market production
    s_xyz_r::Function = x -&gt; p_xyz_r(x) .- b_x_r(x) #surplus
end
</code></pre>

<pre><code class="language-julia">p = Params();
</code></pre>

<h3 id="ii-b-value-function-iteration">II. B. Value function iteration</h3>

<p>To check the accuracy of the ANN approach, we will also use another &ldquo;legacy&rdquo; method to find another approximation for $S(x,y,z)$. The traditional way is to use <strong>Value Function Iteration (VFI)</strong>. For a detailed treatment, the textbook of <a href="https://www.google.com/search?q=Recursive+methods+in+economic+dynamics&amp;client=ubuntu&amp;hs=q3T&amp;sa=X&amp;channel=fs&amp;sxsrf=AOaemvLsI7n9lOLie8RSVfOPi0l2weq7Pg:1641306887162&amp;tbm=isch&amp;source=iu&amp;ictx=1&amp;fir=GH2dBz2E9vFPDM%252CzAM-vlBogjsh7M%252C%252Fm%252F0cgvb6c&amp;vet=1&amp;usg=AI4_-kQJc5H3CV04Yfys38GSbnPN50KV5A&amp;ved=2ahUKEwi-xOfPqJj1AhWySvEDHWK1BeUQ_B16BAgbEAI&amp;biw=1232&amp;bih=626&amp;dpr=1.5#imgrc=GH2dBz2E9vFPDM" target="_blank">Stockey and Lucas</a> is a must-read. For explanations with codes, I suggest <a href="https://julia.quantecon.org/dynamic_programming/optgrowth.html" target="_blank">QuantEcon</a>.</p>

<p>VFI, as suggested by the name, is an iterated procedure that converges to the true function. One starts by assuming a function $V^{(0)}$. Then one applies the &ldquo;right-hand-side operator&rdquo; of the Bellman equation to get $V^{(1)}$:</p>

<p>$ V^{(1)}(x,y,z) = s(x,y,z) + \frac{1 - \delta}{1 + r} E_{z&rsquo;|z} [ max(V^{(0)}(x,y,z&rsquo;), 0) ]$</p>

<p>In practice, one must calculate $V^{(n)}(x,y,z)$ on a grid. Off-grid points can be obtained by linear interpolation. After some time, the distance between $V^{(n)}(x,y,z)$ and $V^{(n-1)}(x,y,z)$ is small and the procedure may be stopped.</p>

<h4 id="grid-considerations-unconditional-distribution-of-z">Grid considerations: unconditional distribution of z?</h4>

<p>As explained above, to use VFI, one must define a grid. For the values of $x$ and $y$, representing workers&rsquo; and firms&rsquo; heterogeneity, any bounded interval could do the job. Let&rsquo;s follow the original paper and assume that both $x$ and $y$ are in $[0,1]$.</p>

<p>Defining a good grid for $z$ requires a bit more work. In the model of <a href="https://www.aeaweb.org/articles?id=10.1257/aer.20131118" target="_blank">Lise and Robin 2017</a>, the log (natural logarithm) of the aggregate state $z$ follows an AR(1) process:</p>

<p>$log(z_{t}) = \rho log(z_{t-1}) + \epsilon_{t}$</p>

<p>with $\epsilon_{t}$ normally distributed with variance $\psi \equiv \sigma \times \sqrt(1.0 - \rho^2)$.</p>

<p>This implies that the unconditional distribution of $log(z)$ is normally distributed with mean 0 and variance $\sigma$. Or said differently, $z$ is $Lognormal(0, \sigma)$. In the block of code below, we check this fact by comparing some simulated data and the pdf of a $Lognormal(0, \sigma)$.</p>

<pre><code class="language-julia">Nt = 20000000 #number of draws
d = Normal(0, p.psi)
innov = rand(d, Nt)
log_z = zeros(Nt)
z = zeros(Nt)
log_z[1] = 1.0
for t=2:Nt
    log_z[t] = p.rho*log_z[t-1] + innov[t]
end
z = exp.(log_z)
d_log_normal = LogNormal(0.0, p.sigma)

density(z, label=&quot;data&quot;)
plot!(minimum(z):0.01:maximum(z), x -&gt; pdf(d_log_normal, x), label=&quot;LogNormal&quot;)
</code></pre>

<p><img src="ANN_2_11_0.svg" alt="svg" /></p>

<p>Most of the time, $z$ is going to be between the 5th and the 95th percentile of $Lognormal(0, \sigma)$. Hence, we define the grid for $z$ to be $[P5, P95]$.</p>

<pre><code class="language-julia">P5 = quantile(d_log_normal, 0.05)
P95 = quantile(d_log_normal, 0.95)
println(&quot;P5: $(P5); P95: $(P95)&quot;)
</code></pre>

<pre><code>P5: 0.8891200789438004; P95: 1.1247074761689282
</code></pre>

<pre><code class="language-julia">#Sampling for training
n_samples_xy = 10; #number of draws for the x and y dimensions
n_samples_z = 10; #number of draws for the z dimension
lower_bound = [0.0, 0.0, P5]
upper_bound = [1.0, 1.0, P95]

x_grid = collect(range(lower_bound[1], upper_bound[1], length=n_samples_xy))
y_grid = collect(range(lower_bound[2], upper_bound[2], length=n_samples_xy))
z_grid = collect(range(lower_bound[3], upper_bound[3], length=n_samples_z))

nodes_xyz = (x_grid, y_grid, z_grid, ); #for package Interpolations
</code></pre>

<h4 id="value-function-iteration">Value function iteration</h4>

<p>The following block of code uses the VFI algorithm and displays the final results. The value function $S(x,y,z)$ is a non-linear transformation of the value of net output of the job $s(x,y,z)$.</p>

<pre><code class="language-julia">V_old = zeros(n_samples_xy, n_samples_xy, n_samples_z)
V_new = zeros(n_samples_xy, n_samples_xy, n_samples_z)

# Initial guess
for (zIndex, zValue) in enumerate(z_grid)
    for (yIndex, yValue) in enumerate(y_grid)
        for (xIndex, xValue) in enumerate(x_grid)
            V_old[xIndex, yIndex, zIndex] = p.s_xyz(xValue, yValue, zValue) + ((1.0 - p.delta)/(1.0 + p.r))*max(0.0, p.s_xyz(xValue, yValue, zValue))
        end
    end
end

itp = interpolate(nodes_xyz, V_old, Gridded(Linear()))
etp = extrapolate(itp, Line())
V_old_interpolated = (x) -&gt; etp(x[1], x[2], x[3])

max_iter = 5000
tol = 10^-8

@time begin
    # Initialize
    for i = 1:max_iter

        for (zIndex, zValue) in enumerate(z_grid)
            for (yIndex, yValue) in enumerate(y_grid)
                for (xIndex, xValue) in enumerate(x_grid)
                    V_new[xIndex, yIndex, zIndex] = p.s_xyz(xValue, yValue, zValue) + ((1.0 - p.delta)/(1.0 + p.r)).*sum(p.weigths_E.*[max.(0.0, V_old_interpolated([xValue; yValue; (zValue.^p.rho).*exp.(innovation)])) for innovation in p.nodes_E])
                end
            end
        end

        # DISTANCE
        diff= maximum(abs.(V_new .- V_old))
        if mod(i, 100) == 0
            println(&quot;Iter $(i) Diff : $(diff)&quot;)
        end

        if diff &lt; tol
            println(&quot;Iter $(i) Convergence reached&quot;)
            break
        end

        #UPDATE
        V_old = copy(V_new)
        itp = interpolate(nodes_xyz, V_old, Gridded(Linear()))
        etp = extrapolate(itp, Line())
        V_old_interpolated = (x) -&gt; etp(x[1], x[2], x[3])

    end
end

# Plot output for trained neural network
p1 = plot(p.x_grid, p.y_grid, (x, y) -&gt; V_old_interpolated([x; y; 1.0])[1], label = &quot;f(x)&quot;, st=:surface)
title!(L&quot;S(x,y,z=1)&quot;)
xlabel!(L&quot;x&quot;)
ylabel!(L&quot;y&quot;)

# Initialization function
p2 = plot(p.x_grid, p.y_grid, (x, y) -&gt; p.s_xyz(x, y, 1.0), label = &quot;f(x)&quot;, st=:surface)
title!(L&quot;s(x,y,z=1)&quot;)
xlabel!(L&quot;x&quot;)
ylabel!(L&quot;y&quot;)

p3 = plot(p.x_grid, p.y_grid, (x, y) -&gt; V_old_interpolated([x; y; 1.0])[1], label = &quot;f(x)&quot;, st=:contour)
title!(L&quot;S(x,y,z=1)&quot;)
xlabel!(L&quot;x&quot;)
ylabel!(L&quot;y&quot;)

p4 = plot(p.x_grid, p.y_grid, (x, y) -&gt; p.s_xyz(x, y, 1.0), label = &quot;f(x)&quot;, st=:contour)
title!(L&quot;s(x,y,z=1)&quot;)
xlabel!(L&quot;x&quot;)
ylabel!(L&quot;y&quot;)

ratio = 9/16
width = 800
pp = plot(p1, p2, p3, p4, size = (width, width*ratio))
</code></pre>

<pre><code>Iter 100 Diff : 0.18062930117157094
Iter 200 Diff : 0.04545706889411605
Iter 300 Diff : 0.011441422819899572
Iter 400 Diff : 0.002880196260427681
Iter 500 Diff : 0.0007251468880724588
Iter 600 Diff : 0.00018259564639322434
Iter 700 Diff : 4.598479092265961e-5
Iter 800 Diff : 1.1582340917470901e-5
Iter 900 Diff : 2.9176678424391866e-6
Iter 1000 Diff : 7.350753179480307e-7
Iter 1100 Diff : 1.8521812705785123e-7
Iter 1200 Diff : 4.6675602050072484e-8
Iter 1300 Diff : 1.1763880536364013e-8
Iter 1312 Convergence reached
 43.861711 seconds (266.61 M allocations: 12.326 GiB, 3.34% gc time, 0.15% compilation time)
</code></pre>

<p><img src="ANN_2_16_1.svg" alt="svg" /></p>

<h3 id="ii-c-bellman-ann">II.C. Bellman - ANN</h3>

<p>When doing value function iteration, one does not have to vectorize the code. However, I have learned the hard-way that it matters quite a lot when switching to the ANN approach, especially if you aim to use a GPU. So let&rsquo;s tackle this problem right now.</p>

<p>The trick is to realize that the expectation operator is just a large weighted average, which can be represented by a matrix multiplication when grid points are chosen carefully.</p>

<p>Let&rsquo;s consider all the value of $S(x,y,z)$ from the grid, arranged in a large row vector of dimension $(1; n_x \times n_y \times n_z)$ : $$ \small \begin{pmatrix}
S(x_1,y_1, z_1) &amp; S(x_2,y_1, z_1) &amp; &hellip; &amp; S(x_{nx},y_1, z_1) &amp; S(x_{1},y_2, z_1) &amp; &hellip; &amp; S(x_{nx},y_{ny}, z_{nz}) \end{pmatrix}$$</p>

<p>Using this convention, one can verify that the initial Bellman equation can be written as:</p>

<p>$$ \small \begin{pmatrix}
S(x_1,y_1, z_1) &amp; S(x_2,y_1, z_1) &amp; &hellip; &amp; S(x_{nx},y_{ny}, z_{nz})
\end{pmatrix} = \begin{pmatrix}s(x_1,y_1, z_1) &amp; s(x_2,y_1, z_1) &amp; &hellip; &amp; s(x_{nx},y_{ny}, z_{nz}) \end{pmatrix} + \frac{1 - \delta}{1 + r} \begin{pmatrix}
S(x_1,y_1, z_1&rsquo;|z_1) &amp; S(x_1,y_1, z_2&rsquo;|z_1) &amp; &hellip; &amp; S(x_1,y_1, z_{nz&rsquo;}|z_1) &amp; S(x_2,y_1, z_{1&rsquo;}|z_1) &amp; &hellip; &amp; S(x_{nx},y_{ny}, z_{nz&rsquo;}|z_{nz}) \end{pmatrix} \times W
$$</p>

<p>where $W$ is large (sparse) matrix of dimension $(n_x \times n_y \times n_z \times n_{z&rsquo;}; n_x \times n_y \times n_z)$ containing the weights to approximate the expectation operator:</p>

<p>$$ \small
W \equiv \begin{pmatrix} w1 &amp; w2 &amp; &hellip; &amp; w_{nz&rsquo;} &amp; 0 &amp; &hellip; &amp; 0 \\ 0 &amp; 0 &amp; &hellip; &amp; 0 &amp; w1 &amp; w2 &amp; &hellip; &amp; w_{nz&rsquo;} &amp; 0 &amp; &hellip; 0 \\ 0 &amp; 0 &amp; &hellip; &amp; 0 &amp; 0 &amp; 0 &amp; &hellip; &amp; 0 &amp; w1 &amp; w2 &amp; &hellip; &amp; w_{nz&rsquo;} \end{pmatrix}^T
$$</p>

<p>For this vectorized approach to work, we need to define two grids:</p>

<ul>
<li><p>one grid for the &ldquo;today&rsquo;s part&rdquo;:
$\small \begin{pmatrix} S(x_1,y_1, z_1) &amp; S(x_2,y_1, z_1) &amp; &hellip; &amp; S(x_{nx},y_{ny}, z_{nz}) \end{pmatrix} $ and $\begin{pmatrix}s(x_1,y_1, z_1) &amp; s(x_2,y_1, z_1) &amp; &hellip; &amp; s(x_{nx},y_{ny}, z_{nz}) \end{pmatrix}$</p></li>

<li><p>one grid for the &ldquo;expectation part&rdquo; (the value of $z$ tomorrow depends on the value today) $\small \begin{pmatrix} S(x_1,y_1, z_1&rsquo;|z_1) &amp; S(x_1,y_1, z_2&rsquo;|z_1) &amp; &hellip; &amp; S(x_1,y_1, z_{nz&rsquo;}|z_1) &amp; S(x_2,y_1, z_{1&rsquo;}|z_1) &amp; &hellip; &amp; S(x_{nx},y_{ny}, z_{nz&rsquo;}|z_{nz}) \end{pmatrix}$</p></li>
</ul>

<p>I also define some grid points that are not used for the gradient descent phase (the &ldquo;test set&rdquo;). These points allow us to verify that we are not overfitting the training sample.</p>

<pre><code class="language-julia">nb_dim = 3

#-------------------------------------------------------------
# Train set
#-------------------------------------------------------------
# Grid for the LHS
# Grid (1, nx * ny * nz )
grid_1 = zeros(nb_dim, n_samples_xy*n_samples_xy*n_samples_z);

index = 1
for (xValue, yValue, zValue) in product(x_grid, y_grid, z_grid)
    grid_1[1, index] = xValue
    grid_1[2, index] = yValue
    grid_1[3, index] = zValue
    index+=1
end

# Grid for the RHS (calculate expectations)
# Grid (1, nx * ny * nz * nz')
grid_2 = zeros(nb_dim, n_samples_xy*n_samples_xy*n_samples_z*p.nb_nodes);

# Populate grid_2
index = 1
for (xValue, yValue, zValue) in product(x_grid, y_grid, z_grid)
    for (innovation_index, innovation) in enumerate(p.nodes_E)
        grid_2[1, index] = xValue
        grid_2[2, index] = yValue
        grid_2[3, index] = (zValue.^p.rho).*exp.(innovation)
        index+=1
    end
end

#-------------------------------------------------------------
# Test set
#-------------------------------------------------------------
# Sampling for test
n_samples_test = 1000
grid_test_1 = zeros(nb_dim, n_samples_test);

index = 1
for (xValue, yValue, zValue) in Surrogates.sample(n_samples_test, lower_bound, upper_bound, SobolSample())
    grid_test_1[1, index] = xValue
    grid_test_1[2, index] = yValue
    grid_test_1[3, index] = zValue
    index+=1
end

grid_test_2 = zeros(nb_dim, n_samples_xy*n_samples_xy*n_samples_z*p.nb_nodes);

# Populate grid_test_2
index = 1
for (xValue, yValue, zValue) in zip(grid_test_1[1,:], grid_test_1[2,:], grid_test_1[3,:])
    for (innovation_index, innovation) in enumerate(p.nodes_E)
        grid_test_2[1, index] = xValue
        grid_test_2[2, index] = yValue
        grid_test_2[3, index] = (zValue.^p.rho).*exp.(innovation)
        index+=1
    end
end

# To calculate the expectation
W = sparse(kronecker(Matrix(I, n_samples_xy*n_samples_xy*n_samples_z, n_samples_xy*n_samples_xy*n_samples_z), p.weigths_E));
</code></pre>

<pre><code class="language-julia"># Define the neural network layers
# Specify our model
dim_input = 3
dim_ouptut = 1

Q1 = 300;
Q2 = 100;
Q3 = 10;

activation_f = relu;

model = Chain(Dense(dim_input,Q1,activation_f),
            Dense(Q1,Q2,activation_f),
            Dense(Q2,Q3,activation_f),
            Dense(Q3,dim_ouptut,identity));
</code></pre>

<p>Check one pass of the gradient:</p>

<pre><code class="language-julia">ps = Flux.params(model)
y = zeros(1, size(grid_1, 2))
s_xyz_r = transpose(p.s_xyz_r(grid_1)) #precalculate net output on grid

@time begin
    gs = gradient(() -&gt; Flux.Losses.mse(model(grid_1) - s_xyz_r + ((1.0 - p.delta)/(1.0 + p.r)).*max.(0.0, model(grid_2))*W, y), ps)
end
</code></pre>

<h4 id="initializing-the-model">Initializing the model</h4>

<p>We can start with random coefficients and try to solve for the function S(.) directly.
However, it is better to initialize the coefficients of the ANN to match a not too far-fetched guess:</p>

<pre><code class="language-julia">lr = 0.001 # learning rate when batchsize = 1000
opt = ADAM(lr)

epochs_training = 100 # Define the number of epochs
trainingLosses = zeros(epochs_training); # Keep track of the training progress
testLosses = zeros(epochs_training); # Test on data not used in the training

ps = Flux.params(model) #initialize weigths
p_bar = Progress(epochs_training; desc = &quot;Training in progress&quot;); # Creates a progress bar
showProgress = true

y = zeros(1, size(grid_1, 2))
s_xyz_r = transpose(p.s_xyz_r(grid_1)) #precalculate net output on grid
s_xyz_r_test = transpose(p.s_xyz_r(grid_test_1)) #precalculate net output on test grid

# Training loop
@time for ii in 1:epochs_training

    gs = gradient(() -&gt; Flux.Losses.mse(model(grid_1) - s_xyz_r - ((1.0 - p.delta)/(1.0 + p.r)).*max.(0.0, s_xyz_r), y), ps)# compute gradient
    Flux.Optimise.update!(opt, ps, gs) # update parameters


    if showProgress
        trainingLosses[ii] = Flux.Losses.mse(model(grid_1) - s_xyz_r - ((1.0 - p.delta)/(1.0 + p.r)).*max.(0.0, s_xyz_r), y)
        testLosses[ii] = Flux.Losses.mse(model(grid_test_1) - s_xyz_r_test - ((1.0 - p.delta)/(1.0 + p.r)).*max.(0.0, s_xyz_r_test), y)
        next!(p_bar; showvalues = [(:epochs, ii), (:logloss, log.(trainingLosses[ii])), (:loglosstest, log.(testLosses[ii]))], valuecolor = :grey)
    end

end


</code></pre>

<pre><code>┌ Warning: ProgressMeter by default refresh meters with additional information in IJulia via `IJulia.clear_output`, which clears all outputs in the cell.
│  - To prevent this behaviour, do `ProgressMeter.ijulia_behavior(:append)`.
│  - To disable this warning message, do `ProgressMeter.ijulia_behavior(:clear)`.
└ @ ProgressMeter /home/julien/.julia/packages/ProgressMeter/Vf8un/src/ProgressMeter.jl:620
[32mTraining in progress100%|███████████████████████████████| Time: 0:00:07[39m
[39m  epochs:       100[39m
[39m  logloss:      -6.198231731362997[39m
[39m  loglosstest:  -6.480455135391009[39m


  7.398687 seconds (285.46 k allocations: 2.889 GiB, 5.29% gc time, 5.06% compilation time)
</code></pre>

<pre><code class="language-julia">init_f = (x,y,z) -&gt; p.s_xyz(x,y,z) .+ ((1.0 - p.delta)/(1.0 + p.r)).*max.(0.0, p.s_xyz(x,y,z))

gr()
# Plot output for trained neural network
p1 = plot(p.x_grid, p.y_grid, (x, y) -&gt; model([x; y; 1.0])[1], label = &quot;f(x)&quot;, st=:surface)
title!(&quot;ANN&quot;)
xlabel!(&quot;x&quot;)
ylabel!(&quot;y&quot;)

# Plot training loss
p2 = plot(1:epochs_training, log.(trainingLosses), label = &quot;Train set&quot;, linewidth = 2)
plot!(1:epochs_training, log.(testLosses), label = &quot;Test set&quot;, linewidth = 2)
title!(&quot;Log Training Loss&quot;)
xlabel!(&quot;Epoch&quot;)
ylabel!(L&quot;\log(\textrm{Loss})&quot;)

# Plot training loss
# Plot output for trained neural network
p3 = plot(p.x_grid, p.y_grid, (x, y) -&gt; init_f(x, y, 1.0), label = &quot;f(x)&quot;, st=:surface)
title!(&quot;Initial Guess&quot;)
xlabel!(&quot;x&quot;)
ylabel!(&quot;y&quot;)

# Plot training loss
# Plot output for trained neural network
p4 = plot(p.x_grid, p.y_grid, (x, y) -&gt; model([x; y; 1.0])[1] - init_f(x, y, 1.0), label = &quot;f(x)&quot;, st=:surface)
title!(&quot;Initial Guess - VFI&quot;)
xlabel!(&quot;x&quot;)
ylabel!(&quot;y&quot;)


ratio = 9/16
width = 800
pp = plot(p1, p2, p3, p4, size = (width, width*ratio))
</code></pre>

<p><img src="ANN_2_24_0.svg" alt="svg" /></p>

<h4 id="solving-the-real-problem">Solving the real problem</h4>

<p>Now that the coefficients are initialized, let&rsquo;s tackle the real problem:</p>

<pre><code class="language-julia">lr = 0.001 # learning rate
opt = ADAM(lr)

epochs_training = 1000 # Define the number of epochs
trainingLosses = zeros(epochs_training); # Keep track of the training progress
testLosses = zeros(epochs_training); # Test on data not used in the training

ps = Flux.params(model) #initialize weigths
p_bar = Progress(epochs_training; desc = &quot;Training in progress&quot;); # Creates a progress bar
showProgress = true

y = zeros(1, size(grid_1, 2))
s_xyz_r = transpose(p.s_xyz_r(grid_1)) #precalculate net output on grid
s_xyz_r_test = transpose(p.s_xyz_r(grid_test_1)) #precalculate net output on test grid

# Training loop
@time for ii in 1:epochs_training

    gs = gradient(() -&gt; Flux.Losses.mse(model(grid_1) - s_xyz_r - ((1.0 - p.delta)/(1.0 + p.r)).*max.(0.0, model(grid_2))*W, y), ps)# compute gradient
    Flux.Optimise.update!(opt, ps, gs) # update parameters

    if showProgress
        trainingLosses[ii] = Flux.Losses.mse(model(grid_1) - s_xyz_r - ((1.0 - p.delta)/(1.0 + p.r)).*max.(0.0, model(grid_2))*W, y)
        testLosses[ii] = Flux.Losses.mse(model(grid_test_1) - s_xyz_r_test - ((1.0 - p.delta)/(1.0 + p.r)).*max.(0.0, model(grid_test_2))*W, y)
        next!(p_bar; showvalues = [(:epochs, ii), (:logloss, log.(trainingLosses[ii])), (:loglosstest, log.(testLosses[ii]))], valuecolor = :grey)
    end

end
</code></pre>

<pre><code>┌ Warning: ProgressMeter by default refresh meters with additional information in IJulia via `IJulia.clear_output`, which clears all outputs in the cell.
│  - To prevent this behaviour, do `ProgressMeter.ijulia_behavior(:append)`.
│  - To disable this warning message, do `ProgressMeter.ijulia_behavior(:clear)`.
└ @ ProgressMeter /home/julien/.julia/packages/ProgressMeter/Vf8un/src/ProgressMeter.jl:620
[32mTraining in progress100%|███████████████████████████████| Time: 0:08:47[39m
[39m  epochs:       1000[39m
[39m  logloss:      -7.247630080617367[39m
[39m  loglosstest:  -7.022159208051979[39m


527.918020 seconds (2.05 M allocations: 380.917 GiB, 0.84% gc time, 0.08% compilation time)
</code></pre>

<p>Training on the full problem is succesfull, as illustrated on the graphs below. It is hard to see meaningfull differences between
VFI and the ANN methods.</p>

<pre><code class="language-julia">gr()
# Plot output for trained neural network
p1 = plot(p.x_grid, p.y_grid, (x, y) -&gt; model([x; y; 1.0])[1], label = &quot;f(x)&quot;, st=:surface)
title!(&quot;ANN&quot;)
xlabel!(&quot;x&quot;)
ylabel!(&quot;y&quot;)

# Plot training loss
p2 = plot(1:epochs_training, log.(trainingLosses), label = &quot;Train set&quot;, linewidth = 2)
plot!(1:epochs_training, log.(testLosses), label = &quot;Test set&quot;, linewidth = 2)
title!(&quot;Log Training Loss&quot;)
xlabel!(&quot;Epoch&quot;)
ylabel!(L&quot;\log(\textrm{Loss})&quot;)

# Plot training loss
# Plot output for trained neural network
p3 = plot(p.x_grid, p.y_grid, (x, y) -&gt; V_old_interpolated([x; y; 1.0])[1], label = &quot;f(x)&quot;, st=:surface)
title!(&quot;VFI&quot;)
xlabel!(&quot;x&quot;)
ylabel!(&quot;y&quot;)

# Plot training loss
# Plot output for trained neural network
p4 = plot(p.x_grid, p.y_grid, (x, y) -&gt; model([x; y; 1.0])[1] - V_old_interpolated([x; y; 1.0])[1], label = &quot;f(x)&quot;, st=:surface)
title!(&quot;ANN - VFI&quot;)
xlabel!(&quot;x&quot;)
ylabel!(&quot;y&quot;)


ratio = 9/16
width = 800
pp = plot(p1, p2, p3, p4, size = (width, width*ratio))
</code></pre>

<p><img src="ANN_2_28_0.svg" alt="svg" /></p>

<pre><code class="language-julia">zValue = 1.0

p1 = plot(p.x_grid, p.y_grid, (x, y) -&gt; model([x; y; zValue])[1], label = &quot;f(x)&quot;, st=:contour)
title!(&quot;ANN&quot;)
xlabel!(&quot;x&quot;)
ylabel!(&quot;y&quot;)

p2 = plot(p.x_grid, p.y_grid, (x, y) -&gt; V_old_interpolated([x,y, zValue]), label = &quot;f(x)&quot;, st=:contour)
title!(&quot;VFI&quot;)
xlabel!(&quot;x&quot;)
ylabel!(&quot;y&quot;)

plot(p1, p2)
</code></pre>

<p><img src="ANN_2_29_0.svg" alt="svg" /></p>

<h4 id="accuracy-tests">Accuracy tests</h4>

<p>Accuracy of VFI versus ANN approaches can be assessed by looking at off-grid points.
In the present setting, VFI outperforms the ANN approach. However, I conjecture that in a high-dimensional setting the opposite would be true (in a high-dimensional setting, VFI probably would not be possible in the first place). Also, one could increase the number of epochs and get better results.</p>

<pre><code class="language-julia">#VFI
#LHS
LHS = zeros(size(grid_test_1, 2))
index = 1
for (xValue, yValue, zValue) in zip(grid_test_1[1, :], grid_test_1[2, :], grid_test_1[3,:])
    LHS[index] = V_old_interpolated([xValue; yValue; zValue])
    index+=1
end


#RHS
RHS = zeros(size(grid_test_1, 2))
index = 1
for (xValue, yValue, zValue) in zip(grid_test_1[1, :], grid_test_1[2, :], grid_test_1[3,:])
    RHS[index] = p.s_xyz(xValue, yValue, zValue) + ((1.0 - p.delta)/(1.0 + p.r)).*sum(p.weigths_E.*[max.(0.0, V_old_interpolated([xValue; yValue; (zValue.^p.rho).*exp.(innovation)])) for innovation in p.nodes_E])
    index+=1
end

#ANN
error_ANN = model(grid_test_1) - transpose(p.s_xyz_r(grid_test_1)) - ((1.0 - p.delta)/(1.0 + p.r)).*max.(0.0, model(grid_test_2)*W)
error_ANN = transpose(error_ANN)
p1 = histogram(LHS - RHS, label=&quot;errors VFI&quot;)
p2 = histogram(error_ANN, label=&quot;errors ANN&quot;)
plot(p1, p2)
</code></pre>

<p><img src="ANN_2_31_0.svg" alt="svg" /></p>

<pre><code class="language-julia">df = DataFrame(Method = [&quot;VFI&quot;, &quot;ANN&quot;],
                MSE = [mean(LHS .- RHS).^2, mean(error_ANN).^2],
                MDSE = [median(LHS .- RHS).^2, median(error_ANN).^2],
                MAXSE = [maximum(LHS .- RHS).^2, maximum(error_ANN).^2],
                MINSE = [minimum(LHS .- RHS).^2, minimum(error_ANN).^2])

df
</code></pre>

<table class="data-frame"><thead><tr><th></th><th>Method</th><th>MSE</th><th>MDSE</th><th>MAXSE</th><th>MINSE</th></tr><tr><th></th><th>String</th><th>Float64</th><th>Float64</th><th>Float64</th><th>Float64</th></tr></thead><tbody><p>2 rows × 5 columns</p><tr><th>1</th><td>VFI</td><td>1.99895e-6</td><td>3.47266e-7</td><td>0.00288945</td><td>1.5217e-6</td></tr><tr><th>2</th><td>ANN</td><td>7.47681e-5</td><td>1.37991e-5</td><td>0.035538</td><td>0.00108539</td></tr></tbody></table>

<h2 id="conclusion">Conclusion</h2>

<p>In this blog post, I showed how ANN can be used to find unknown functions satisfying a Bellman equation.</p>

<p>The code presented here is more a <strong>proof-of-concept than a production-ready release</strong>. A first obvious improvement is to train the ANN on a <strong>GPU instead of a CPU</strong>. Using the free version of <a href="https://colab.research.google.com/" target="_blank">Google Colab</a>, I am getting an almost 10x time improvement. A second improvement would be to use more diverse set of points for the ANN. While VFI requires a fixed grid to make sense, the ANN is a grid-less method. The training phase would benefit from more mixing in the input points.</p>

<p>As a final remark, I chose on purpose a problem which is a bit simpler than the full general problem, in which one must also find the policy function that comes with the unknown value function. I am wondering if some of the insights described in the <a href="https://www.nature.com/articles/nature16961" target="_blank">Alpha Go paper</a> could apply in the present setting.</p>

    </div>

    


<div class="article-tags">
  
  <a class="badge badge-light" href="/tags/numerical/">Numerical</a>
  
  <a class="badge badge-light" href="/tags/ai/">AI</a>
  
</div>




    
      






  







<div class="media author-card" itemscope itemtype="http://schema.org/Person">
  
  
  <img class="portrait mr-3" src="/author/admin/avatar_hu3ebf584d0e96ded762042713d38b4f6f_6501895_250x250_fill_q90_lanczos_center.jpg" itemprop="image" alt="Avatar">
  

  <div class="media-body">
    <h5 class="card-title" itemprop="name"><a href="/authors/admin">Julien Pascal, PhD</a></h5>
    <h6 class="card-subtitle">Economist</h6>
    
    <ul class="network-icon" aria-hidden="true">
      
      
      
      
        
      
      
      
      
      
        
      
      <li>
        <a itemprop="sameAs" href="https://twitter.com/Juli3nPascal" target="_blank" rel="noopener">
          <i class="fab fa-twitter"></i>
        </a>
      </li>
      
      
      
      
        
      
      
      
      
      
        
      
      <li>
        <a itemprop="sameAs" href="https://github.com/JulienPascal" target="_blank" rel="noopener">
          <i class="fab fa-github"></i>
        </a>
      </li>
      
      
      
      
        
      
      
      
      
      
        
      
      <li>
        <a itemprop="sameAs" href="https://www.linkedin.com/in/julien-pascal-62a322aa/" target="_blank" rel="noopener">
          <i class="fab fa-linkedin"></i>
        </a>
      </li>
      
      
      
      
        
      
      
      
      
      
        
      
      <li>
        <a itemprop="sameAs" href="https://medium.com/@julien.pascal" target="_blank" rel="noopener">
          <i class="fab fa-medium"></i>
        </a>
      </li>
      
    </ul>
  </div>
</div>



      
      
      <div class="article-widget">
        <div class="hr-light"></div>
        <h3>Related</h3>
        <ul>
          
          <li><a href="/post/ann_1/">Artificial Neural Networks as universal function approximators</a></li>
          
        </ul>
      </div>
      
    

    

    


  </div>
</article>

<div class="container">
  <footer class="site-footer">
  

  <p class="powered-by">
    &copy; 2017 Julien Pascal &middot; 

    Powered by the
    <a href="https://sourcethemes.com/academic/" target="_blank" rel="noopener">Academic theme</a> for
    <a href="https://gohugo.io" target="_blank" rel="noopener">Hugo</a>.

    
    <span class="float-right" aria-hidden="true">
      <a href="#" id="back_to_top">
        <span class="button_icon">
          <i class="fas fa-chevron-up fa-2x"></i>
        </span>
      </a>
    </span>
    
  </p>
</footer>

</div>


<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

    

    
    
    
    <script src="/js/mathjax-config.js"></script>
    

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js" integrity="sha512-+NqPlbbtM1QqiK8ZAo4Yrj2c4lNQoGv8P79DPtKzj++l5jnN39rHA/xsqn8zE9l0uSoxaCdrOgFs6yjyfbBxSg==" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/4.1.3/js/bootstrap.min.js" integrity="sha256-VsEqElsCHSGmnmHXGQzvoWjWwoznFSZc6hs7ARLRacQ=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" integrity="sha256-X5PoE3KU5l+JcX+w09p/wHl9AzK333C4hJ2I9S5mD4M=" crossorigin="anonymous"></script>

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js" integrity="sha256-/BfiIkHlHoVihZdc6TFuj7MmJ0TWcWsMXkeDFwhi0zw=" crossorigin="anonymous"></script>
        
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/julia.min.js"></script>
        
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/python.min.js"></script>
        
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/shell.min.js"></script>
        
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/r.min.js"></script>
        
      

      
      
      <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-AMS_CHTML-full" integrity="sha256-GhM+5JHb6QUzOQPXSJLEWP7R73CbkisjzK5Eyij4U9w=" crossorigin="anonymous" async></script>
      
    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.2.0/leaflet.js" integrity="sha512-lInM/apFSqyy1o6s89K4iQUKg6ppXEgsVxT35HbzUupEVRh2Eu9Wdl4tHj7dZO0s1uvplcYGmt3498TtHq+log==" crossorigin="anonymous"></script>
    

    
    
    

    
    
    <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script>
      const search_index_filename = "/index.json";
      const i18n = {
        'placeholder': "Search...",
        'results': "results found",
        'no_results': "No results found"
      };
      const content_type = {
        'post': "Posts",
        'project': "Projects",
        'publication' : "Publications",
        'talk' : "Talks"
        };
    </script>
    

    
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
      <div class="search-hit-content">
        <div class="search-hit-name">
          <a href="{{relpermalink}}">{{title}}</a>
          <div class="article-metadata search-hit-type">{{type}}</div>
          <p class="search-hit-description">{{snippet}}</p>
        </div>
      </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    

    
    
    
    
    
    
    
      
    
    
    
    
    <script src="/js/academic.min.d7381f2d79e6271d4da28f474f49096c.js"></script>

  </body>
</html>

