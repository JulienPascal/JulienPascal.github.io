<!DOCTYPE html>
<html lang="en-us">
<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="theme" content="hugo-academic">
  <meta name="generator" content="Hugo 0.53" />
  <meta name="author" content="Julien Pascal">
  <meta name="description" content="PhD candidate in Economics">

  
  
  
    
  
  
    
    
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/github.min.css">
    
  
  
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha512-6MXa8B6uaO18Hid6blRMetEIoPqHf7Ux1tnyIQdpt9qI5OACx7C+O3IVTr98vwGnlcg0LOLa02i9Y1HpVhlfiw==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.0/css/academicons.min.css" integrity="sha512-GGGNUPDhnG8LEAEDsjqYIQns+Gu8RBs4j5XGlxl7UfRaZBhCCm5jenJkeJL8uPuOXGqgl8/H1gjlWQDRjd3cUQ==" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha512-SfTiTlX6kk+qitfevl/7LibUOeJWlt9rbyDn92a1DqWOw9vWG2MFoays0sgObmWazO5BQPiFucnnEAjpAB+/Sw==" crossorigin="anonymous">
  
  
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather%7CRoboto+Mono">
  <link rel="stylesheet" href="/css/hugo-academic.css">
  

  
    <script>
      window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
      ga('create', 'UA-114454001-1', 'auto');
      ga('require', 'eventTracker');
      ga('require', 'outboundLinkTracker');
      ga('require', 'urlChangeTracker');
      ga('send', 'pageview');
    </script>
    <script async src="//www.google-analytics.com/analytics.js"></script>
    
    <script async src="https://cdnjs.cloudflare.com/ajax/libs/autotrack/2.4.1/autotrack.js" integrity="sha512-HUmooslVKj4m6OBu0OgzjXXr+QuFYy/k7eLI5jdeEy/F4RSgMn6XRWRGkFi5IFaFgy7uFTkegp3Z0XnJf3Jq+g==" crossorigin="anonymous"></script>
    
  

  <link rel="alternate" href="https://julienpascal.github.io/index.xml" type="application/rss+xml" title="Julien Pascal">
  <link rel="feed" href="https://julienpascal.github.io/index.xml" type="application/rss+xml" title="Julien Pascal">

  <link rel="icon" type="image/png" href="/img/icon.png">
  <link rel="apple-touch-icon" type="image/png" href="/img/apple-touch-icon.png">

  <link rel="canonical" href="https://julienpascal.github.io/post/smm/">

  

  <title>The Simulated Method of Moments | Julien Pascal</title>

</head>
<body id="top" data-spy="scroll" data-target="#navbar-main" data-offset="71">

<nav class="navbar navbar-default navbar-fixed-top" id="navbar-main">
  <div class="container">

    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse"
              data-target=".navbar-collapse" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Julien Pascal</a>
    </div>

    
    <div class="collapse navbar-collapse">

      
      <ul class="nav navbar-nav navbar-right">
        

        

        <li class="nav-item">
          <a href="/#about">
            
            <span>Home</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#projects">
            
            <span>Projects</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#teaching">
            
            <span>Teaching</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#publications">
            
            <span>Publications</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#posts">
            
            <span>Posts</span>
          </a>
        </li>

        
        

        

        <li class="nav-item">
          <a href="/#contact">
            
            <span>Contact</span>
          </a>
        </li>

        
        

        
      </ul>

    </div>
  </div>
</nav>


<article class="article" itemscope itemtype="http://schema.org/Article">

  


  <div class="article-container">
    <h1 itemprop="name">The Simulated Method of Moments</h1>
    

<div class="article-metadata">

  <span class="article-date">
    <time datetime="2018-02-12 00:00:00 &#43;0000 UTC" itemprop="datePublished">
      Mon, Feb 12, 2018
    </time>
  </span>

  

  
  
  
  

  
  
<div class="share-box" aria-hidden="true">
  <ul class="share">
    <li>
      <a class="facebook"
         href="https://www.facebook.com/sharer.php?u=https%3a%2f%2fjulienpascal.github.io%2fpost%2fsmm%2f"
         target="_blank">
        <i class="fa fa-facebook"></i>
      </a>
    </li>
    <li>
      <a class="twitter"
         href="https://twitter.com/intent/tweet?text=The%20Simulated%20Method%20of%20Moments&amp;url=https%3a%2f%2fjulienpascal.github.io%2fpost%2fsmm%2f"
         target="_blank">
        <i class="fa fa-twitter"></i>
      </a>
    </li>
    <li>
      <a class="linkedin"
         href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fjulienpascal.github.io%2fpost%2fsmm%2f&amp;title=The%20Simulated%20Method%20of%20Moments"
         target="_blank">
        <i class="fa fa-linkedin"></i>
      </a>
    </li>
    <li>
      <a class="weibo"
         href="http://service.weibo.com/share/share.php?url=https%3a%2f%2fjulienpascal.github.io%2fpost%2fsmm%2f&amp;title=The%20Simulated%20Method%20of%20Moments"
         target="_blank">
        <i class="fa fa-weibo"></i>
      </a>
    </li>
    <li>
      <a class="email"
         href="mailto:?subject=The%20Simulated%20Method%20of%20Moments&amp;body=https%3a%2f%2fjulienpascal.github.io%2fpost%2fsmm%2f">
        <i class="fa fa-envelope"></i>
      </a>
    </li>
  </ul>
</div>


  

</div>

    <div class="article-style" itemprop="articleBody">
      

<p>As Thomas Sargent said:</p>

<blockquote>
<p>&ldquo;A rational expectations equilibrium model is a likelihood function&rdquo;</p>
</blockquote>

<p>However in many cases, the likelihood function is too complicated to be
written down in closed form. To estimate the structural parameters of the model, one can still use Monte-Carlo methods. In this post, I would like to describe the <a href="https://en.wikipedia.org/wiki/Method_of_simulated_moments" target="_blank">simulated method of moments</a> (SMM), which is a widely used simulation-based estimation technique.</p>

<h2 id="a-simple-setting">A Simple Setting</h2>

<p>I want to illustrate the SMM in one of the simplest settings you could think of:
the estimation of the mean of a normal density. Let&rsquo;s say we have access to a (bi-dimensional) time series and we suspect it to be normally distributed with mean $[a,\,b]&lsquo;$ and variance the identity matrix $\mathcal{N}([a,\,b]&lsquo;,\,I_2)$. Let&rsquo;s pretend that we have no idea how to write down the associated likelihood function. The good news is that we have access to a &ldquo;black box&rdquo; that generates $i.i.d$ draws from the law $\mathcal{N}([c,\,d]&lsquo;,\,I_2)$, for any value $c$ and $d$ . It turns out that having access to this black box is enough for
us to do inference.</p>

<h2 id="smm-is-gmm">SMM is GMM</h2>

<p>The SMM estimator can be viewed as an extension of the GMM one, as the SMM requires simulated data as well as empirical data. Mathematically, we want to minimize the objective function:</p>

<p><img src="/img/equation_SMM.png" alt="SMM objective function\label{objective_function}" /></p>

<p>where $m^*$ is a vector of moments based on empirical observations, $m(\theta)$ a vector of the same moments
calculated using simulated data when the structural parameters are equal to $\theta$, and $W$ a <a href="https://en.wikipedia.org/wiki/Weighing_matrix" target="_blank">weighing matrix</a>.</p>

<p>The SMM estimate will be such that the (weighted) distance between simulated and real-world moments is minimized. This estimator is quite intuitive: under the hypothesis that the model is correctly specified, it should be able to reproduce the stylized facts of the data when the parameters are equal to the &ldquo;true&rdquo; ones.</p>

<h2 id="inference">Inference</h2>

<p>Under some regularity conditions (see <a href="https://www.google.fr/search?client=ubuntu&amp;channel=fs&amp;q=+McFadden+1989&amp;ie=utf-8&amp;oe=utf-8&amp;gfe_rd=cr&amp;dcr=0&amp;ei=a52BWsGULYeO8Qfq-p3YCw" target="_blank">McFadden 1989</a>), the extra noise introduced by simulation is
not problematic and inference is possible. That is, we can build a confidence interval
for our SMM estimates using the standard GMM approach.</p>

<p>An interesting fact is that the histogram of one Markov chain realization, $S=\big( \theta^1, \theta^2, &hellip;, \theta^N \big)$, behaves like a &ldquo;quasi-posterior&rdquo; distribution (see <a href="http://www.mit.edu/~vchern/ch_qbe.pdf" target="_blank">Chernozhukov 2003</a>). The beauty of this approach is that for a given continously differentiable function $g:\Theta \rightarrow â„œ$, the $90\%$ confidence intervals are constructed by taking the $0.05th$ and $0.95th$ quantiles of the sequence  $g(S)=\big( g(\theta^1), g(\theta^2), &hellip;, g(\theta^N )\big)$.</p>

<h2 id="implementation-in-julia">Implementation in Julia</h2>

<p>The code below shows how one can recover the true parameters of the Normal density $\mathcal{N}([a,\,b]&lsquo;,\,I_2)$. I use the <a href="https://github.com/floswald/MomentOpt.jl" target="_blank">MomentOpt</a> package, which uses some <a href="(https://arxiv.org/abs/1108.3423)" target="_blank">refinements</a> of the <a href="(https://arxiv.org/abs/1108.3423)" target="_blank">MCMC</a> method to explore the state-space with several Markov chains in parallel. These Markov chains communicate between themselves to avoid being stuck in a local mode of the posterior distribution. In practice, I choose 5 Markov chains. Figure 1 shows the realizations for the first chain. As illustrated in Figure 2, we successfully recovered the true values for $a$ and $b$. For each chain, the quasi-posterior mean and median for $a$ and $b$ are extremely close to the true values $1$ and $-1$.</p>

<h4 id="figure-1">Figure 1</h4>

<table>
<thead>
<tr>
<th align="center"><img src="/img/history_chain_1.svg" alt="history one chain" /></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><em>History of one chain</em></td>
</tr>
</tbody>
</table>

<h4 id="figure-2">Figure 2</h4>

<table>
<thead>
<tr>
<th align="center"><img src="/img/histogram.svg" alt="histogram SMM" /></th>
</tr>
</thead>

<tbody>
<tr>
<td align="center"><em>Histograms for the 5 chains</em></td>
</tr>
</tbody>
</table>

<pre><code class="language-julia">#---------------------------------------------------------------------------------------------------------
# Julien Pascal
# last edit: 12/02/2018
#
# Julia script that shows how the simulated
# method of moments can be used in a simple
# setting: estimation of the mean of a Normal r.v.
#
# I use the package MomentOpt: https://github.com/floswald/MomentOpt.jl
#
# Code heavily based on the file https://github.com/floswald/MomentOpt.jl/blob/master/src/mopt/Examples.jl
#----------------------------------------------------------------------------------------------------------

using MomentOpt
using GLM
using DataStructures
using DataFrames
using Plots
#plotlyjs()
pyplot()

#------------------------------------------------
# Options
#-------------------------------------------------
# Boolean: do you want to save the plots to disk?
savePlots = true

# initialize the problem:
#------------------------
# initial values:
#----------------
pb    = OrderedDict(&quot;p1&quot; =&gt; [0.2,-3,3] , &quot;p2&quot; =&gt; [-0.2,-2,2] )
# moments to be matched:
#-----------------------
moms = DataFrame(name=[&quot;mu1&quot;,&quot;mu2&quot;],value=[-1.0,1.0], weight=ones(2))



&quot;&quot;&quot;
    objfunc_normal(ev::Eval)

    GMM objective function to be minized.
    It returns a weigthed distance between empirical and simulated moments

    copy-paste of the function objfunc_norm(ev::Eval)
    I only made minor modifications to the original fuction

&quot;&quot;&quot;

function objfunc_normal(ev::Eval)

    start(ev)


    # extract parameters from ev:
    #----------------------------
    mu  = collect(values(ev.params))

    # compute simulated moments
    #--------------------------
    # Monte-Carlo:
    #-------------
    ns = 10000 #number of i.i.d draws from N([a,b], sigma)
    #initialize a multivariate normal N([a,b], sigma)
    #using a = mu[1], b=mu[2]
    sigma = [1.0 ;1.0]
    randMultiNormal = MomentOpt.MvNormal(mu,MomentOpt.PDiagMat(sigma))
    simM            = mean(rand(randMultiNormal,ns),2) #mean of simulated data
    simMoments = Dict(:mu1 =&gt; simM[1], :mu2 =&gt; simM[2])#store simulated moments in a dictionary


    # Calculate the weighted distance between empirical moments
    # and simulated ones:
    #-----------------------------------------------------------
    v = Dict{Symbol,Float64}()
    for (k, mom) in dataMomentd(ev)
        # If weight for moment k exists:
        #-------------------------------
        if haskey(MomentOpt.dataMomentWd(ev), k)
            # divide by weight associated to moment k:
            #----------------------------------------
            v[k] = ((simMoments[k] .- mom) ./ MomentOpt.dataMomentW(ev,k)) .^2
        else
            v[k] = ((simMoments[k] .- mom) ) .^2
        end
    end

    # Set value of the objective function:
    #------------------------------------
    setValue(ev, mean(collect(values(v))))

    # also return the moments
    #-----------------------
    setMoment(ev, simMoments)

    # flag for success:
    #-------------------
    ev.status = 1

    # finish and return
    finish(ev)

    return ev
end



# Initialize an empty MProb() object:
#------------------------------------
mprob = MProb()

# Add structural parameters to MProb():
# specify starting values and support
#--------------------------------------
addSampledParam!(mprob,pb)

# Add moments to be matched to MProb():
#--------------------------------------
addMoment!(mprob,moms)

# Attach an objective function to MProb():
#----------------------------------------
addEvalFunc!(mprob, objfunc_normal)


# estimation options:
#--------------------
# number of iterations for each chain
niter = 1000
# number of chains
nchains = 5

opts = Dict(&quot;N&quot;=&gt;nchains,
        &quot;maxiter&quot;=&gt;niter,
        &quot;maxtemp&quot;=&gt; 5,
        # choose inital sd for each parameter p
        # such that Pr( x \in [init-b,init+b]) = 0.975
        # where b = (p[:ub]-p[:lb])*opts[&quot;coverage&quot;] i.e. the fraction of the search interval you want to search around the initial value
        &quot;coverage&quot;=&gt;0.025,  # i.e. this gives you a 95% CI about the current parameter on chain number 1.
        &quot;sigma_update_steps&quot;=&gt;10,
        &quot;sigma_adjust_by&quot;=&gt;0.01,
        &quot;smpl_iters&quot;=&gt;1000,
        &quot;parallel&quot;=&gt;true,
        &quot;maxdists&quot;=&gt;[0.05 for i in 1:nchains],
        &quot;mixprob&quot;=&gt;0.3,
        &quot;acc_tuner&quot;=&gt;12.0,
        &quot;animate&quot;=&gt;false)


# plot slices of objective function
#---------------------------------
s = doSlices(mprob,30)

# plot objective function over param values:
#-------------------------------------------
p1 = MomentOpt.plot(s,:value)

if savePlots == true
    Plots.savefig(p1, joinpath(pwd(),&quot;slices_Normal1.svg&quot;))
end

# plot value of moment :mu1 over param values
#--------------------------------------------
p2 = MomentOpt.plot(s,:mu1)


if savePlots == true
   Plots.savefig(p2, joinpath(pwd(),&quot;slices_Normal2.svg&quot;))
end

# plot value of moment :mu2 over param values
#--------------------------------------------
p3 = Plots.plot(s,:mu2)

if savePlots == true
    Plots.savefig(p3, joinpath(pwd(),&quot;slices_Normal3.svg&quot;))
end

#---------------------------------------
# Let's set-up and run the optimization
#---------------------------------------
# set-up BGP algorithm:
MA = MAlgoBGP(mprob,opts)

# run the estimation:
@time MomentOpt.runMOpt!(MA)

# show a summary of the optimization:
@show MomentOpt.summary(MA)

# Plot histograms for chains:
#----------------------------
p4 = histogram(MA.chains[1])
p5 = histogram(MA.chains[2])
p6 = histogram(MA.chains[3])
p7 = histogram(MA.chains[4])
p8 = histogram(MA.chains[5])

p9 = Plots.plot(p4, p5, p6, p7, p8, layout=(5,1), legend=false)

if savePlots == true
    savefig(p9, joinpath(pwd(),&quot;histogram.svg&quot;))
end

# Plot the &quot;history&quot; of one chain:
#--------------------------------
p10 = plot(MA.chains[1])
if savePlots == true
    savefig(p10, joinpath(pwd(),&quot;history_chain_1.svg&quot;))
end


# Realization of chain 1:
#-----------------------
dat_chain1 = MomentOpt.history(MA.chains[1])

# keep only accepted draws:
#-------------------------
dat_chain1 = dat_chain1[dat_chain1[:accepted ].== true, : ]


# Quasi Posterior mean
#---------------------
QP_mean_p1 = mean(dat_chain1[:p1])
QP_mean_p2 = mean(dat_chain1[:p2])

# Quasi Posterior median
#-----------------------
QP_median_p1 = median(dat_chain1[:p1])
QP_median_p2 = median(dat_chain1[:p2])
</code></pre>

    </div>
  </div>

</article>

<div class="container">
  <nav>
  <ul class="pager">
    
    <li class="previous"><a href="https://julienpascal.github.io/post/collocation_method/"><span
      aria-hidden="true">&larr;</span> Solving Bellman Equations by the Collocation Method</a></li>
    

    
    <li class="next"><a href="https://julienpascal.github.io/post/smm_parallel/">The Simulated Method of Moments: a Parallel Implementation <span
      aria-hidden="true">&rarr;</span></a></li>
    
  </ul>
</nav>

</div>

<div class="article-container">
  

</div>

<footer class="site-footer">
  <div class="container">
    <p class="powered-by">

      &copy; 2017 Julien Pascal &middot; 

      Powered by the <a href="https://github.com/gcushen/hugo-academic" target="_blank">Academic
      theme</a> for <a href="http://gohugo.io" target="_blank">Hugo</a>.

      <span class="pull-right" aria-hidden="true">
        <a href="#" id="back_to_top">
          <span class="button_icon">
            <i class="fa fa-chevron-up fa-2x"></i>
          </span>
        </a>
      </span>

    </p>
  </div>
</footer>

    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.12.4/jquery.min.js" integrity="sha512-jGsMH83oKe9asCpkOVkBnUrDDTp8wl+adkB2D+//JtlxO4SrLoJdhbOysIFQJloQFD+C4Fl1rMsQZF76JjV0eQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.2/imagesloaded.pkgd.min.js" integrity="sha512-iHzEu7GbSc705hE2skyH6/AlTpOfBmkx7nUqTLGzPYR+C1tRaItbRlJ7hT/D3YQ9SV0fqLKzp4XY9wKulTBGTw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/TweenMax.min.js" integrity="sha512-Z5heTz36xTemt1TbtbfXtTq5lMfYnOkXM2/eWcTTiLU01+Sw4ku1i7vScDc8fWhrP2abz9GQzgKH5NGBLoYlAw==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/1.19.1/plugins/ScrollToPlugin.min.js" integrity="sha512-CDeU7pRtkPX6XJtF/gcFWlEwyaX7mcAp5sO3VIu/ylsdR74wEw4wmBpD5yYTrmMAiAboi9thyBUr1vXRPA7t0Q==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha512-iztkobsvnjKfAtTNdHkGVjAYTrrtlC7mGp/54c40wowO7LhURYl3gVzzcEqGl/qKXQltJ2HwMrdLcNUdo+N/RQ==" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.4/isotope.pkgd.min.js" integrity="sha512-VDBOIlDbuC4VWxGJNmuFRQ0Li0SKkDpmGyuhAG5LTDLd/dJ/S0WMVxriR2Y+CyPL5gzjpN4f/6iqWVBJlht0tQ==" crossorigin="anonymous"></script>
    
    <script src="/js/hugo-academic.js"></script>
    

    
    
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>

      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/julia.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/python.min.js"></script>
      
      <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/shell.min.js"></script>
      

      

      <script>hljs.initHighlightingOnLoad();</script>
    

    
    
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']] } });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML" integrity="sha512-tOav5w1OjvsSJzePRtt2uQPFwBoHt1VZcUq8l8nm5284LEKE9FSJBQryzMBzHxY5P0zRdNqEcpLIRVYFNgu1jw==" crossorigin="anonymous"></script>
    
    

  </body>
</html>

